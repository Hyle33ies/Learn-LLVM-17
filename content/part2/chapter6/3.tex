
To allow source-level debugging, we have to add debug information. Support for debug information in LLVM uses debug metadata to describe the types of the source language and other static information, and intrinsics to track variable values. The LLVM core libraries generate debug information in the DWARF format on Unix systems and in PDB format for Windows. We’ll look at the general structure in the next section.

\mySubsubsection{6.3.1.}{Understanding the general structure of debug metadata}

To describe the general structure, LLVM uses metadata similar to the metadata for type-based analysis. The static structure describes the file, the compilation unit, functions and lexical blocks, and the used data types.

The main class we use is llvm::DIBuilder, and we need to use the llvm/IR/DIBuilder header file to get the class declaration. This builder class provides an easy-to-use interface to create the debug metadata. Later, the metadata is either added to LLVM objects such as global variables, or is used in calls to debug intrinsics. Here’s some important metadata that the builder class can create:

\begin{itemize}
\item
llvm::DIFile: This describes a file using the filename and the absolute path of the directory containing the file. You use the createFile() method to create it. A file can contain the main compilation unit or it could contain imported declarations.

\item
llvm::DICompileUnit: This is used to describe the current compilation unit. Among other things, you specify the source language, a compiler-specific producer string, whether optimizations are enabled or not, and, of course, DIFile, in which the compilation unit resides. You create it with a call to createCompileUnit().

\item
llvm::DISubprogram: This describes a function. The most important information here is the scope (usually DICompileUnit or DISubprogram for a nested function), the name of the function, the mangled name of the function, and the function type. It is created with a call to createFunction().

\item
llvm::DILexicalBlock: This describes a lexical block and models the block scoping found in many high-level languages. You can create this with a call to createLexicalBlock().
\end{itemize}

LLVM makes no assumptions about the language your compiler translates. As a consequence, it has no information about the data types of the language. To support source-level debugging, especially displaying variable values in a debugger, type information must be added too. Here are some important constructs:

\begin{itemize}
\item
The createBasicType() function, which returns a pointer to the llvm::DIBasicType class, creates the metadata to describe a basic type such as INTEGER in tinylang or int in C++. Besides the name of the type, the required parameters are the size in bits and the encoding – for example, if it is a signed or unsigned type.

\item
There are several ways to construct the metadata for composite data types, as represented by the llvm::DIComposite class. You can use the createArrayType(), createStructType(), createUnionType(), and createVectorType() functions to instantiate the metadata for array, struct, union, and vector data types, respectively. These functions require the parameter you expect, such as the base type and the number of subscriptions for an array type or a list of the field members of a struct type.

\item
There are also methods to support enumerations, templates, classes, and so on.
\end{itemize}

The list of functions shows you that you have to add every detail of the source language to the debug information. Let’s assume your instance of the llvm::DIBuilder class is called DBuilder. Let’s also assume that you have some tinylang source in a file called File.mod in the /home/llvmuser folder. Inside this file is the Func():INTEGER function at line 5, which contains a local VAR i:INTEGER declaration at line 7. Let’s create the metadata for this, beginning with the information for the file. You need to specify the filename and the absolute path of the folder in which the file resides:

\begin{cpp}
llvm::DIFile *DbgFile = DBuilder.createFile("File.mod",
                                            "/home/llvmuser");
\end{cpp}

The file is a module in tinylang, which makes it the compilation unit for LLVM. This carries a lot of information:

\begin{cpp}
bool IsOptimized = false;
llvm::StringRef CUFlags;
unsigned ObjCRunTimeVersion = 0;
llvm::StringRef SplitName;
llvm::DICompileUnit::DebugEmissionKind EmissionKind =
    llvm::DICompileUnit::DebugEmissionKind::FullDebug;
llvm::DICompileUnit *DbgCU = DBuilder.createCompileUnit(
    llvm::dwarf::DW_LANG_Modula2, DbgFile, "tinylang",
    IsOptimized, CUFlags, ObjCRunTimeVersion, SplitName,
    EmissionKind);
\end{cpp}

Furthermore, the debugger needs to know the source language. The DWARF standard defines an enumeration with all the common values. One disadvantage of this is that you cannot simply add a new source language. To do that, you have to create a request at the DWARF committee. Be aware that the debugger and other debug tools also need support for a new language – just adding a new member to the enumeration is not enough.

In many cases, it is sufficient to choose a language that is close to your source language. In the case of tinylang, this is Modula-2, and we use DW\_LANG\_Modula2 as the language identifier. A compilation unit resides in a file, which is identified by the DbgFile variable we created previously.

Additionally, the debug information can carry information about the producer, which can be the name of the compiler and version information. Here, we just pass the tinylang string. If you do not want to add this information, then you can simply use an empty string as a parameter.

The next set of information includes the IsOptimized flag, which should indicate if the compiler has turned optimization on or not. Usually, this flag is derived from the –O command-line switch.
You can pass additional parameter settings to the debugger with the CUFlags parameter. This is not used here, and we pass an empty string. We also do not use Objective-C, so we pass 0 as the Objective-C runtime version.

Normally, debug information is embedded in the object file we are creating. If we want to write the debug information into a separate file, then the SplitName parameter must contain the name of this file. Otherwise, simply passing an empty string is sufficient. Finally, you can define the level of debug information that should be emitted. The default is full debug information, as indicated by the use of the FullDebug enum value, but you can also choose the LineTablesOnly value if you want to emit only line numbers, or the NoDebug value for no debug information at all. For the latter, it is better to not create debug information in the first place.

Our minimalistic source only uses the INTEGER data type, which is a signed 32-bit value. Creating the metadata for this type is straightforward:

\begin{cpp}
llvm::DIBasicType *DbgIntTy =
    DBuilder.createBasicType("INTEGER", 32,
        llvm::dwarf::DW_ATE_signed);
\end{cpp}

To create the debug metadata for the function, we have to create a type for the signature first, and then the metadata for the function itself. This is similar to the creation of IR for a function. The signature of the function is an array with all the types of parameters in source order and the return type of the function as the first element at index 0. Usually, this array is constructed dynamically. In our case, we can also construct the metadata statically. This is useful for internal functions, such as for module initializing. Typically, the parameters of these functions are always known, and the compiler writer can hard-code them:

\begin{cpp}
llvm::Metadata *DbgSigTy = {DbgIntTy};
llvm::DITypeRefArray DbgParamsTy =
            DBuilder.getOrCreateTypeArray(DbgSigTy);
llvm::DISubroutineType *DbgFuncTy =
            DBuilder.createSubroutineType(DbgParamsTy);
\end{cpp}

Our function has the INTEGER return type and no further parameters, so the DbgSigTy array only contains the pointer to the metadata for this type. This static array is turned into a type array, which is then used to create the type for the function.

The function itself requires more data:

\begin{cpp}
unsigned LineNo = 5;
unsigned ScopeLine = 5;
llvm::DISubprogram *DbgFunc = DBuilder.createFunction(
    DbgCU, "Func", "_t4File4Func", DbgFile, LineNo,
    DbgFuncTy, ScopeLine, llvm::DISubprogram::FlagPrivate,
    llvm::DISubprogram::SPFlagLocalToUnit);
\end{cpp}

A function belongs to a compilation unit, which in our case is stored in the DbgCU variable. We need to specify the name of the function in the source file, which is Func, and the mangled name is stored in the object file. This information helps the debugger locate the machine code of the function. The mangled name, based on the rules of tinylang, is \_t4File4Func. We also have to specify the file that contains the function.

This may sound surprising at first, but think of the include mechanism in C and C++: a function can be stored in a different file, which is then included with \#include in the main compilation unit. Here, this is not the case and we use the same file as the one the compilation unit uses. Next, the line number of the function and the function type are passed. The line number of the function may not be the line number where the lexical scope of the function begins. In this case, you can specify a different ScopeLine. A function also has protection, which we specify here with the FlagPrivate value to indicate a private function. Other possible values for function protection are FlagPublic and FlagProtected, for public and protected functions, respectively.

Besides the protection level, other flags can be specified here. For example, FlagVirtual indicates a virtual function and FlagNoReturn indicates that the function does not return to the caller. You can find the complete list of possible values in the LLVM include file – that is, llvm/include/ llvm/IR/DebugInfoFlags.def.

Lastly, flags specific to a function can be specified. The most commonly used flag is the SPFlagLocalToUnit value, which indicates that the function is local to this compilation unit.
The MainSubprogram value is also used often, indicating that this function is the main function of the application. The LLVM include file mentioned previously also lists all possible values related to flags specific to functions.

So far, we have only created the metadata referring to static data. Variables are dynamic, so we’ll explore how to attach the static metadata to the IR code for accessing variables in the next section.

\mySubsubsection{6.3.2.}{Tracking variables and their values}

To be useful, the type metadata described in the previous section needs to be associated with variables of the source program. For a global variable, this is pretty easy. The createGlobalVariableExpression() function of the llvm::DIBuilder class creates the metadata to describe a global variable. This includes the name of the variable in the source, the mangled name, the source file, and so on. A global variable in LLVM IR is represented by an instance of the GlobalVariable class. This class has a method called addDebugInfo(), which associates the metadata node returned from createGlobalVariableExpression() with the global variable.

For local variables, we need to take another approach. LLVM IR does not know of a class representing a local variable as it only knows about values. The solution the LLVM community has developed is to insert calls to intrinsic functions into the IR code of a function. An intrinsic function is a function that LLVM knows about and, therefore, can do some magic with it. In most cases, intrinsic functions do not result in a subroutine call at the machine level. Here, the function call is a convenient vehicle to associate the metadata with a value. The most important intrinsic functions for debug metadata are llvm.dbg.declare and llvm.dbg.value.

The llvm.dbg.declare intrinsic provides information and is generated once by the frontend to declare a local variable. Essentially, this intrinsic describes the address of a local variable. During optimization, passes can replace this intrinsic with (possibly multiple) calls to llvm.dbg.value to preserve the debug information and to track the local source variables. After optimization, multiple calls to llvm.dbg.declare may be present as it is used to describe the program points where the local variables live within memory.

On the other hand, the llvm.dbg.value intrinsic is called whenever a local variable is set to a new value. This intrinsic describes the value of a local variable, not its address.

How does all of this work? The LLVM IR representation and the programmatic creation via the llvm::DIBuilder class differ a bit, so we will look at both.

Continuing with our example from the previous section, we’ll allocate local storage for the I variable inside the Func function with the alloca instruction:

\begin{shell}
@i = alloca i32
\end{shell}

After that, we must add a call to the llvm.dbg.declare intrinsic:

\begin{shell}
call void @llvm.dbg.declare(metadata ptr %i,
                metadata !1, metadata !DIExpression())
\end{shell}

The first parameter is the address to the local variable. The second parameter is the metadata describing the local variable, which is created by a call to either createAutoVariable() for a local variable or createParameterVariable() for a parameter of the llvm::DIBuilder class. Finally, the third parameter describes an address expression, which will be explained later.

Let’s implement the IR creation. You can allocate the storage for the local @i variable with a call to the CreateAlloca() method of the llvm::IRBuilder<> class:

\begin{cpp}
llvm::Type *IntTy = llvm::Type::getInt32Ty(LLVMCtx);
llvm::Value *Val = Builder.CreateAlloca(IntTy, nullptr, "i");
\end{cpp}

The LLVMCtx variable is the used context class, and Builder is the used instance of the llvm::IRBuilder<> class.

A local variable also needs to be described by metadata:

\begin{cpp}
llvm::DILocalVariable *DbgLocalVar =
    Dbuilder.createAutoVariable(DbgFunc, "i", DbgFile,
                                7, DbgIntTy);
\end{cpp}

Using the values from the previous section, we can specify that the variable is part of the DbgFunc function, is called i, is defined in the DbgFile file at line 7, and is of the DbgIntTy type.

Finally, we associate the debug metadata with the address of the variable using the llvm.dbg. declare intrinsic. Using llvm::DIBuilder shields you from all of the details of adding a call:

\begin{cpp}
llvm::DILocation *DbgLoc =
                llvm::DILocation::get(LLVMCtx, 7, 5, DbgFunc);
DBuilder.insertDeclare(Val, DbgLocalVar,
                        DBuilder.createExpression(), DbgLoc,
                        Val.getParent());
\end{cpp}

Again, we have to specify a source location for the variable. An instance of llvm::DILocation is a container that holds the line and column of a location associated with a scope. Furthermore, the insertDeclare() method adds the call to the intrinsic function of the LLVM IR. In terms of this function’s parameters, it requires the address of the variable, stored in Val, and the debug metadata for the variable, stored in DbgValVar. We also pass an empty address expression and the debug location we created previously. As with normal instructions, we need to specify into which basic block the call is inserted. If we specify a basic block, then the call is inserted at the end. Alternatively, we can specify an instruction, and the call is inserted before that instruction. We also have the pointer to the alloca instruction, which is the last instruction that we inserted into the underlying basic block. Therefore, we can use this basic block, and the call gets appended after the alloca instruction.

If the value of a local variable changes, then a call to llvm.dbg.value must be added to the IR to set the new value of a local variable. The insertValue() method of the llvm::DIBuilder class can be used to achieve this.

When we implemented the IR generation for functions, we used an advanced algorithm that mainly used values and avoided allocating storage for local variables. In terms of adding debug information, this only means that we use llvm.dbg.value much more often than you see it in clang-generated IR.

What can we do if the variable does not have dedicated storage space but is part of a larger, aggregate type? One of the situations where this can arise is with the use of nested functions. To implement access to the stack frame of the caller, you must collect all used variables in a structure and pass a pointer to this record to the called function. Inside the called function, you can refer to the variables of the caller as if they are local to the function. What is different is that these variables are now part of an aggregate.

In the call to llvm.dbg.declare, you use an empty expression if the debug metadata describes the whole memory the first parameter is pointing to. However, if it only describes a part of the memory, then you need to add an expression indicating which part of the memory the metadata applies to.

In the case of the nested frame, you need to calculate the offset in the frame. You need access to a DataLayout instance, which you can get from the LLVM module into which you are creating the IR code. If the llvm::Module instance is named Mod, and the variable holding the nested frame structure is named Frame and is of the llvm::StructType type, you can access the third member of the frame in the following manner. This access gives you the offset of the member:

\begin{cpp}
const llvm::DataLayout &DL = Mod->getDataLayout();
uint64_t Ofs = DL.getStructLayout(Frame)->getElementOffset(3);
\end{cpp}

Moreover, the expression is created from a sequence of operations. To access the third member of the frame, the debugger needs to add the offset to the base pointer. As an example, you need to create an array and this information like so:

\begin{cpp}
llvm::SmallVector<int64_t, 2> AddrOps;
AddrOps.push_back(llvm::dwarf::DW_OP_plus_uconst);
AddrOps.push_back(Offset);
\end{cpp}

From this array, you can create the expression that you must then pass to llvm.dbg.declare instead of the empty expression:

\begin{cpp}
llvm::DIExpression *Expr = DBuilder.createExpression(AddrOps);
\end{cpp}

It is important to note that you are not limited to this offset operation. DWARF knows many different operators, and you can create fairly complex expressions. You can find the complete list of operators in the LLVM include file, called llvm/include/llvm/BinaryFormat/Dwarf.def.

At this point, you can create debug information for variables. To enable the debugger to follow the control flow in the source, you also need to provide line number information. This is the topic of the next section.

\mySubsubsection{6.3.3.}{Adding line numbers}

A debugger allows a programmer to step through an application line by line. For this, the debugger needs to know which machine instructions belong to which line in the source. LLVM allows adding a source location to each instruction. In the previous section, we created location information of the llvm::DILocation type. A debug location provides more information than just the line, column, and scope. If needed, the scope into which this line is inlined can be specified. It is also possible to indicate that this debug location belongs to implicit code – that is, code that the frontend has generated but is not in the source.

Before this information can be attached to an instruction, we must wrap the debug location in a llvm::DebugLoc object. To do so, you must simply pass the location information obtained from the llvm::DILocation class to the llvm::DebugLoc constructor. With this wrapping, LLVM can track the location information. While the location in the source does not change, the generated machine code for a source-level statement or expression can be dropped during optimization. This encapsulation helps deal with these possible changes.

Adding line number information mostly boils down to retrieving the line number information from the AST and adding it to the generated instructions. The llvm::Instruction class has the setDebugLoc() method, which attaches the location information to the instruction.

In the next section, we’ll learn how to generate debug information and add it to our tinylang compiler.

\mySubsubsection{6.3.4.}{Adding debug support to tinylang}

We encapsulate the generation of debug metadata in the new CGDebugInfo class. Additionally, we place the declaration in the tinylang/CodeGen/CGDebugInfo.h header file and the definition in the tinylang/CodeGen/CGDebugInfo.cpp file.

The CGDebugInfo class has five important members. We need a reference to the code generator for the module, CGM, because we need to convert types from AST representation into LLVM types. Of course, we also need an instance of the llvm::DIBuilder class called Dbuilder, as we did in the previous sections. A pointer to the instance of the compile unit is also needed; we store it in the CU member.

To avoid having to create the debug metadata for types again, we must also add a map to cache this information. The member is called TypeCache. Finally, we need a way to manage the scope information, for which we must create a stack based on the llvm::SmallVector<> class called ScopeStack. Thus, we have the following:

\begin{cpp}
CGModule &CGM;
llvm::DIBuilder DBuilder;
llvm::DICompileUnit *CU;
llvm::DenseMap<TypeDeclaration *, llvm::DIType *>
    TypeCache;
llvm::SmallVector<llvm::DIScope *, 4> ScopeStack;
\end{cpp}

The following methods of the CGDebugInfo class make use of these members:

\begin{enumerate}
\item
First, we need to create the compile unit, which we do in the constructor. We also create the file containing the compile unit here. Later, we can refer to the file through the CU member.
The code for the constructor is as follows:

\begin{cpp}
CGDebugInfo::CGDebugInfo(CGModule &CGM)
        : CGM(CGM), DBuilder(*CGM.getModule()) {
    llvm::SmallString<128> Path(
        CGM.getASTCtx().getFilename());
    llvm::sys::fs::make_absolute(Path);

    llvm::DIFile *File = DBuilder.createFile(
        llvm::sys::path::filename(Path),
        llvm::sys::path::parent_path(Path));

    bool IsOptimized = false;
    llvm::StringRef CUFlags;
    unsigned ObjCRunTimeVersion = 0;
    llvm::StringRef SplitName;
    llvm::DICompileUnit::DebugEmissionKind EmissionKind =
        llvm::DICompileUnit::DebugEmissionKind::FullDebug;
    CU = DBuilder.createCompileUnit(
        llvm::dwarf::DW_LANG_Modula2, File, "tinylang",
        IsOptimized, CUFlags, ObjCRunTimeVersion,
        SplitName, EmissionKind);
}
\end{cpp}

\item
Often, we need to provide a line number. The line number can be derived from the source manager location, which is available in most AST nodes. The source manager can convert this into a line number:

\begin{cpp}
    CGDebugInfo::CGDebugInfo(CGModule &CGM)
unsigned CGDebugInfo::getLineNumber(SMLoc Loc) {
    return CGM.getASTCtx().getSourceMgr().FindLineNumber(
        Loc);
}
\end{cpp}

\item
The information about a scope is held on a stack. We need methods to open and close a scope and retrieve the current scope. The compilation unit is the global scope, which we add automatically:

\begin{cpp}
llvm::DIScope *CGDebugInfo::getScope() {
    if (ScopeStack.empty())
    openScope(CU->getFile());
    return ScopeStack.back();
}

void CGDebugInfo::openScope(llvm::DIScope *Scope) {
    ScopeStack.push_back(Scope);
}

void CGDebugInfo::closeScope() {
    ScopeStack.pop_back();
}
\end{cpp}

\item
Next, we must create a method for each category of type we need to transform. The getPervasiveType() method creates the debug metadata for basic types. Note the use of the encoding parameter, which declares the INTEGER type as a signed type and the BOOLEAN type encoded as a Boolean:

\begin{cpp}
llvm::DIType *
CGDebugInfo::getPervasiveType(TypeDeclaration *Ty) {
    if (Ty->getName() == "INTEGER") {
        return DBuilder.createBasicType(
            Ty->getName(), 64, llvm::dwarf::DW_ATE_signed);
    }
    if (Ty->getName() == "BOOLEAN") {
        return DBuilder.createBasicType(
            Ty->getName(), 1, llvm::dwarf::DW_ATE_boolean);
    }
    llvm::report_fatal_error(
        "Unsupported pervasive type");
}
\end{cpp}

\item
If the type name is simply renamed, then we must map this to a type definition. Here, we need to make use of the scope and line number information:

\begin{cpp}
llvm::DIType *
CGDebugInfo::getAliasType(AliasTypeDeclaration *Ty) {
    return DBuilder.createTypedef(
        getType(Ty->getType()), Ty->getName(),
        CU->getFile(), getLineNumber(Ty->getLocation()),
        getScope());
}
\end{cpp}

\item
Creating the debug information for an array requires specifying the size and the alignment. We can retrieve this data from the DataLayout class. We also need to specify the index range of the array:

\begin{cpp}
llvm::DIType *
CGDebugInfo::getArrayType(ArrayTypeDeclaration *Ty) {
    auto *ATy =
        llvm::cast<llvm::ArrayType>(CGM.convertType(Ty));
    const llvm::DataLayout &DL =
        CGM.getModule()->getDataLayout();

    Expr *Nums = Ty->getNums();
    uint64_t NumElements =
        llvm::cast<IntegerLiteral>(Nums)
            ->getValue()
            .getZExtValue();
    llvm::SmallVector<llvm::Metadata *, 4> Subscripts;
    Subscripts.push_back(
        DBuilder.getOrCreateSubrange(0, NumElements));
    return DBuilder.createArrayType(
        DL.getTypeSizeInBits(ATy) * 8,
        1 << Log2(DL.getABITypeAlign(ATy)),
        getType(Ty->getType()),
        DBuilder.getOrCreateArray(Subscripts));
}
\end{cpp}

\item
Using all these single methods, we can create a central method to create the metadata for a type. This metadata is also responsible for caching the data:

\begin{cpp}
llvm::DIType *
CGDebugInfo::getType(TypeDeclaration *Ty) {
    if (llvm::DIType *T = TypeCache[Ty])
        return T;
    if (llvm::isa<PervasiveTypeDeclaration>(Ty))
        return TypeCache[Ty] = getPervasiveType(Ty);
    else if (auto *AliasTy =
        llvm::dyn_cast<AliasTypeDeclaration>(Ty))
            return TypeCache[Ty] = getAliasType(AliasTy);
    else if (auto *ArrayTy =
        llvm::dyn_cast<ArrayTypeDeclaration>(Ty))
            return TypeCache[Ty] = getArrayType(ArrayTy);
    else if (auto *RecordTy =
        llvm ::dyn_cast<RecordTypeDeclaration>(Ty))
        r   eturn TypeCache[Ty] = getRecordType(RecordTy);
    llvm::report_fatal_error("Unsupported type");
    return nullptr;
}
\end{cpp}

\item
We also need to add a method to emit metadata for global variables:

\begin{cpp}
void CGDebugInfo::emitGlobalVariable(
VariableDeclaration *Decl,
llvm::GlobalVariable *V) {
    llvm::DIGlobalVariableExpression *GV =
        DBuilder.createGlobalVariableExpression(
            getScope(), Decl->getName(), V->getName(),
            CU->getFile(),
            getLineNumber(Decl->getLocation()),
            getType(Decl->getType()), false);
    V->addDebugInfo(GV);
}
\end{cpp}

\item
To emit the debug information for procedures, we need to create the metadata for the procedure type. For this, we need a list of the types of the parameter, with the return type being the first entry. If the procedure has no return type, then we must use an unspecified type; this is called void, similar to how it is in C. If a parameter is a reference, then we need to add the reference type; otherwise, we must add the type to the list:

\begin{cpp}
llvm::DISubroutineType *
CGDebugInfo::getType(ProcedureDeclaration *P) {
    llvm::SmallVector<llvm::Metadata *, 4> Types;
    const llvm::DataLayout &DL =
        CGM.getModule()->getDataLayout();
    // Return type at index 0
    if (P->getRetType())
        Types.push_back(getType(P->getRetType()));
    else
        Types.push_back(
            DBuilder.createUnspecifiedType("void"));
    for (const auto *FP : P->getFormalParams()) {
        llvm::DIType *PT = getType(FP->getType());
        if (FP->isVar()) {
            llvm::Type *PTy = CGM.convertType(FP->getType());
            PT = DBuilder.createReferenceType(
                llvm::dwarf::DW_TAG_reference_type, PT,
                DL.getTypeSizeInBits(PTy) * 8,
                1 << Log2(DL.getABITypeAlign(PTy)));
        }
        Types.push_back(PT);
    }
    return DBuilder.createSubroutineType(
        DBuilder.getOrCreateTypeArray(Types));
}
\end{cpp}

\item
For the procedure itself, we can now create the debug information using the procedure type we created in the previous step. A procedure also opens a new scope, so we must push the procedure onto the scope stack. We must also associate the LLVM function object with the new debug information:

\begin{cpp}
void CGDebugInfo::emitProcedure(
        ProcedureDeclaration *Decl, llvm::Function *Fn) {
    llvm::DISubroutineType *SubT = getType(Decl);
    llvm::DISubprogram *Sub = DBuilder.createFunction(
        getScope(), Decl->getName(), Fn->getName(),
        CU->getFile(), getLineNumber(Decl->getLocation()),
        SubT, getLineNumber(Decl->getLocation()),
        llvm::DINode::FlagPrototyped,
        llvm::DISubprogram::SPFlagDefinition);
    openScope(Sub);
    Fn->setSubprogram(Sub);
}
\end{cpp}

\item
When the end of a procedure is reached, we must inform the builder to finish constructing the debug information for this procedure. We also need to remove the procedure from the scope stack:

\begin{cpp}
void CGDebugInfo::emitProcedureEnd(
ProcedureDeclaration *Decl, llvm::Function *Fn) {
    if (Fn && Fn->getSubprogram())
        DBuilder.finalizeSubprogram(Fn->getSubprogram());
    closeScope();
}
\end{cpp}

\item
Lastly, when we’ve finished adding the debug information, we need to implement the finalize() method on the builder. The generated debug information is then validated. This is an important step during development as it helps you find wrongly generated metadata:

\begin{cpp}
void CGDebugInfo::finalize() { DBuilder.finalize(); }
\end{cpp}

\end{enumerate}

Debug information should only be generated if the user requested it. This means that we will need a new command-line switch for this. We will add this to the file of the CGModule class, and we will also use it inside this class:

\begin{cpp}
static llvm::cl::opt<bool>
    Debug("g", llvm::cl::desc("Generate debug information"),
        llvm::cl::init(false));
\end{cpp}

The -g option can be used with the tinylang compiler to generate debug metadata.

Furthermore, the CGModule class holds an instance of the std::unique\_ptr<CGDebugInfo> class. The pointer is initialized in the constructor for setting the command-line switch:

\begin{cpp}
    if (Debug)
        DebugInfo.reset(new CGDebugInfo(*this));
\end{cpp}

In the getter method defined in CGModule.h, we simply return the pointer:

\begin{cpp}
CGDebugInfo *getDbgInfo() {
    return DebugInfo.get();
}
\end{cpp}

The common pattern to generate the debug metadata is to retrieve the pointer and check if it is valid. For example, after creating a global variable, we can add the debug information like so:

\begin{cpp}
VariableDeclaration *Var = …;
llvm::GlobalVariable *V = …;
if (CGDebugInfo *Dbg = getDbgInfo())
    Dbg->emitGlobalVariable(Var, V);
\end{cpp}

To add line number information, we need a conversion method called getDebugLoc() in the CGDebugInfo class, which turns the location information from the AST into the debug metadata:

\begin{cpp}
llvm::DebugLoc CGDebugInfo::getDebugLoc(SMLoc Loc) {
    std::pair<unsigned, unsigned> LineAndCol =
        CGM.getASTCtx().getSourceMgr().getLineAndColumn(Loc);
    llvm::DILocation *DILoc = llvm::DILocation::get(
        CGM.getLLVMCtx(), LineAndCol.first, LineAndCol.second,
        getScope());
    return llvm::DebugLoc(DILoc);
}
\end{cpp}

Additionally, a utility function in the CGModule class can be called to add the line number information to an instruction:

\begin{cpp}
void CGModule::applyLocation(llvm::Instruction *Inst,
                             llvm::SMLoc Loc) {
    if (CGDebugInfo *Dbg = getDbgInfo())
        Inst->setDebugLoc(Dbg->getDebugLoc(Loc));
}
\end{cpp}

In this way, you can add the debug information for your compiler.





































