
Two pointers may point to the same memory cell, at which point they alias each other. Memory is not typed in the LLVM model, which makes it difficult for the optimizer to decide if two pointers alias each other or not. If the compiler can prove that two pointers do not alias each other, then more optimizations are possible. In the next section, we will have a closer look at the problem and investigate how adding additional metadata will help before we implement this approach.

\mySubsubsection{6.2.1.}{Understanding the need for additional metadata}

To demonstrate the problem, let’s look at the following function:

\begin{cpp}
void doSomething(int *p, float *q) {
    *p = 42;
    *q = 3.1425;
}
\end{cpp}

The optimizer cannot decide if the pointers, p and q, point to the same memory cell or not. During optimization, an important analysis can be performed called alias analysis. If p and q point to the same memory cell, then they are aliases. Moreover, if the optimizer can prove that both pointers never alias each other, this enables additional optimization opportunities. For example, in the doSomething() function, the stores can be reordered without altering the result in this case.

In addition, it depends on the definition of the source language if a variable of one type can be an alias of another variable of a different type. Please note that languages may also contain expressions that break the type-based alias assumption – for example, type casts between unrelated types.

The solution chosen by the LLVM developers is to add metadata to the load and store instructions. The added metadata serves two purposes:

\begin{itemize}
\item
First, it defines the type hierarchy based on which type may alias another type

\item
Second, it describes the memory access in a load or store instruction
\end{itemize}

Let’s have a look at the type hierarchy in C. Each type of hierarchy starts with a root node, either named or anonymous. LLVM assumes that root nodes with the same name describe the same type of hierarchy. You can use different type hierarchies in the same LLVM modules, and LLVM makes the safe assumption that these types may alias. Beneath the root node, there are the nodes for scalar types. Nodes for aggregate types are not attached to the root node, but they refer to scalar types and other aggregate types. Clang defines the hierarchy for C as follows:

\begin{itemize}
\item
The root node is called Simple C/C++ TBAA.

\item
Beneath the root node is the node for the char types. This is a special type in C because all pointers can be converted into a pointer to char.

\item
Beneath the char node are the nodes for the other scalar types and a type for all pointers, called any pointer.
\end{itemize}

In addition to this, aggregate types are defined as a sequence of member types and offsets.

These metadata definitions are used in access tags attached to the load and store instructions. An access tag is made up of three parts: a base type, an access type, and an offset. Depending on the base type, there are two possible ways the access tag describes memory access:

\begin{enumerate}
\item
If the base type is an aggregate type, then the access tag describes the memory access of a struct member with the necessary access type and is located at the given offset.

\item
If the base type is a scalar type, then the access type must be the same as the base type and the offset must be 0.
\end{enumerate}

With these definitions, we can now define a relation on the access tags, which is used to evaluate if two pointers may alias each other or not. Let’s take a closer look at the options for the immediate parent of a (base type, offset) tuple:

\begin{enumerate}
\item
If the base type is a scalar type and the offset is 0, then the immediate parent is (parent type, 0), with the parent type being the type of the parent node, as defined in the type hierarchy. If the offset is not 0, then the immediate parent is undefined.

\item
If the base type is an aggregate type, then the immediate parent of the (base type, offset) tuple is the (new type, new offset) tuple, with the new type being the type of the member at offset. The new offset is the offset of the new type, adjusted to its new start.
\end{enumerate}

The transitive closure of this relation is the parent relation. Two memory accesses, (base type 1, access type 1, offset 1) and (base type 2, access type 2, offset 2), may alias one another if (base type 1, offset 1) and (base type 2, offset 2) or vice versa are related in the parent relation.

Let’s illustrate this with an example:

\begin{cpp}
struct Point { float x, y; }
void func(struct Point *p, float *x, int *i, char *c) {
    p->x = 0; p->y = 0; *x = 0.0; *i = 0; *c = 0;
}
\end{cpp}

When using the memory access tag definition for scalar types, the access tag for the i parameter is (int, int, 0), while for the c parameter, it is (char, char, 0). In the type hierarchy, the parent of the node for the int type is the char node. Therefore, the immediate parent of (int, 0) is (char, 0) and both pointers can alias. The same is true for the x and c parameters. However, the x and i parameters are not related, so they do not alias each other. The access for the y member of struct Point is (Point, float, 4), with 4 being the offset of the y member in the struct. The immediate parent of (Point, 4) is (float, 0), so the access to p->y and x may alias, and with the same reasoning also with the c parameter.

\mySubsubsection{6.2.2.}{Creating TBAA metadata in LLVM}

To create the metadata, we must use the llvm::MDBuilder class, which is declared in the llvm/IR/MDBuilder.h header file. The data itself is stored in instances of the llvm::MDNode and llvm::MDString classes. Using the builder class shields us from the internal details of the construction.

A root node is created with a call to the createTBAARoot() method, which expects the name of the type hierarchy as a parameter and returns the root node. An anonymous, unique root node can be created with the createAnonymousTBAARoot() method.

A scalar type is added to the hierarchy with the createTBAAScalarTypeNode() method, which takes the name of the type and the parent node as a parameter.

On the other hand, adding a type node for an aggregate type is slightly more complex. The createTBAAStructTypeNode() method takes the name of the type and a list of the fields as parameters. Specifically, the fields are given as a std::pair<llvm::MDNode*, uint64\_t> instance, where the first element indicates the type of the member and the second element represents the offset in struct.

An access tag is created with the createTBAAStructTagNode() method, which takes the base type, the access type, and the offset as parameters.

Lastly, the metadata must be attached to a load or store instruction. The llvm::Instruction class contains a method called setMetadata(), which is used to add various type-based alias analysis metadata. The first parameter must be of the llvm::LLVMContext::MD\_tbaa type and the second must be the access tag.

Equipped with this knowledge, we must add metadata for type-based alias analysis (TBAA) to tinylang.

\mySubsubsection{6.2.3.}{Adding TBAA metadata to tinylang}

To support TBAA, we must add a new CGTBAA class. This class is responsible for generating the metadata nodes. Furthermore, we make the CGTBAA class a member of the CGModule class, calling it TBAA.

Every load and store instruction must be annotated. A new function is created for this purpose in the CGModule class called decorateInst(). This function tries to create the tag access information. If this is successful, the metadata is attached to the respective load or store instruction. Moreover, this design also allows us to turn off the metadata generation process in case we do not need it, such as in builds with optimizations turned off:

\begin{cpp}
void CGModule::decorateInst(llvm::Instruction *Inst,
                            TypeDeclaration *Type) {
    if (auto *N = TBAA.getAccessTagInfo(Type))
        Inst->setMetadata(llvm::LLVMContext::MD_tbaa, N);
}
\end{cpp}

We put the declaration of the new CGTBAA class in the include/tinylang/CodeGen/CGTBAA.h header file and the definition in the lib/CodeGen/CGTBAA.cpp file. Aside from the AST definitions, the header file needs to include the files for defining the metadata nodes and builder:

\begin{cpp}
#include "tinylang/AST/AST.h"
#include "llvm/IR/MDBuilder.h"
#include "llvm/IR/Metadata.h"
\end{cpp}

The CGTBAA class needs to store some data members. So, let’s see how to do this step by step:

\begin{enumerate}
\item
First of all, we need to cache the root of the type hierarchy:

\begin{cpp}
class CGTBAA {
    llvm::MDNode *Root;
\end{cpp}

\item
To construct the metadata nodes, we need an instance of the MDBuilder class:

\begin{cpp}
    llvm::MDBuilder MDHelper;
\end{cpp}

\item
Lastly, we must store the metadata that’s been generated for a type for reuse:

\begin{cpp}
    llvm::DenseMap<TypeDenoter *, llvm::MDNode *> MetadataCache;
    // …
};
\end{cpp}
\end{enumerate}

Now that we’ve defined the variables that are required for the construction, we must add the methods that are required to create the metadata:

\begin{enumerate}
\item
The constructor initializes the data members:

\begin{cpp}
CGTBAA::CGTBAA(CGModule &CGM)
    : CGM(CGM),
    MDHelper(llvm::MDBuilder(CGM.getLLVMCtx())),
    Root(nullptr) {}
\end{cpp}

\item
We must lazily instantiate the root of the type hierarchy, which we name Simple tinylang TBAA:

\begin{cpp}
llvm::MDNode *CGTBAA::getRoot() {
    if (!Root)
        Root = MDHelper.createTBAARoot("Simple tinylang TBAA");
    return Root;
}
\end{cpp}

\item
For a scalar type, we must create a metadata node with the help of the MDBuilder class based
on the name of the type. The new metadata node is stored in the cache:

\begin{cpp}
llvm::MDNode *
CGTBAA::createScalarTypeNode(TypeDeclaration *Ty,
                            StringRef Name,
                            llvm::MDNode *Parent) {
    llvm::MDNode *N =
        MDHelper.createTBAAScalarTypeNode(Name, Parent);
    return MetadataCache[Ty] = N;
}
\end{cpp}

\item
The method to create the metadata for a record is more complicated as we have to enumerate all the fields of the record. Similar to scalar types, the new metadata node is stored in the cache:

\begin{cpp}
llvm::MDNode *CGTBAA::createStructTypeNode(
        TypeDeclaration *Ty, StringRef Name,
        llvm::ArrayRef<std::pair<llvm::MDNode *, uint64_t>> Fields) {
    llvm::MDNode *N =
        MDHelper.createTBAAStructTypeNode(Name, Fields);
    return MetadataCache[Ty] = N;
}
\end{cpp}

\item
To return the metadata for a tinylang type, we need to create the type hierarchy. Due to the type system of tinylang being very restricted, we can use a simple approach. Each scalar type is mapped to a unique type attached to the root node, and we map all pointers to a single type. Structured types then refer to these nodes. If we cannot map a type, then we return nullptr:

\begin{cpp}
llvm::MDNode *CGTBAA::getTypeInfo(TypeDeclaration *Ty) {
    if (llvm::MDNode *N = MetadataCache[Ty])
        return N;

    if (auto *Pervasive =
            llvm::dyn_cast<PervasiveTypeDeclaration>(Ty)) {
        StringRef Name = Pervasive->getName();
        return createScalarTypeNode(Pervasive, Name, getRoot());
    }
    if (auto *Pointer =
            llvm::dyn_cast<PointerTypeDeclaration>(Ty)) {
        StringRef Name = "any pointer";
        return createScalarTypeNode(Pointer, Name, getRoot());
    }
    if (auto *Array =
            llvm::dyn_cast<ArrayTypeDeclaration>(Ty)) {
        StringRef Name = Array->getType()->getName();
        return createScalarTypeNode(Array, Name, getRoot());
    }
    if (auto *Record =
            llvm::dyn_cast<RecordTypeDeclaration>(Ty)) {
        llvm::SmallVector<std::pair<llvm::MDNode *, uint64_t>,
        4> Fields;
        auto *Rec =
            llvm::cast<llvm::StructType>(CGM.convertType(Record));
        const llvm::StructLayout *Layout =
        CGM.getModule()->getDataLayout().getStructLayout(Rec);

        unsigned Idx = 0;
        for (const auto &F : Record->getFields()) {
            uint64_t Offset = Layout->getElementOffset(Idx);
            Fields.emplace_back(getTypeInfo(F.getType()), Offset);
            ++Idx;
        }
        StringRef Name = CGM.mangleName(Record);
        return createStructTypeNode(Record, Name, Fields);
    }
    return nullptr;
}
\end{cpp}

\item
The general method to get the metadata is getAccessTagInfo(). To get the TBAA access tag information, a call to the getTypeInfo() function must be added. This function expects TypeDeclaration as its parameter, which is retrieved from the instructions we want to produce metadata for:

\begin{cpp}
llvm::MDNode *CGTBAA::getAccessTagInfo(TypeDeclaration *Ty) {
    return getTypeInfo(Ty);
}
\end{cpp}

\end{enumerate}

Finally, to enable the generation of TBAA metadata, we simply need to attach the metadata to all of the load and store instructions that we generate within tinylang.

For example, in CGProcedure::writeVariable(), a store to a global variable uses a store instruction:

\begin{cpp}
    Builder.CreateStore(Val, CGM.getGlobal(D));
\end{cpp}

To decorate this particular instruction, we need to replace this line with the following lines, where decorateInst() adds the TBAA metadata to this store instruction:

\begin{cpp}
    auto *Inst = Builder.CreateStore(Val, CGM.getGlobal(D));
    // NOTE: V is of the VariableDeclaration class, and
    // the getType() method in this class retrieves the
    // TypeDeclaration that is needed for decorateInst().
    CGM.decorateInst(Inst, V->getType());
\end{cpp}

With these changes in place, we have finished generating the TBAA metadata.

We can now compile a sample tinylang file into an LLVM intermediate representation to see our newly implemented TBAA metadata. For instance, consider the following file, Person.mod:

\begin{shell}
MODULE Person;

TYPE
    Person = RECORD
                Height: INTEGER;
                Age: INTEGER
             END;

PROCEDURE Set(VAR p: Person);
BEGIN
    p.Age := 18;
END Set;

END Person.
\end{shell}

The tinylang compiler that is built in the build directory of this chapter can be used to generate the intermediate representation for this file:

\begin{shell}
$ tools/driver/tinylang -emit-llvm ../examples/Person.mod
\end{shell}

In the newly generated Person.ll file, we can see that the store instruction is decorated with the TBAA metadata that we have generated within this chapter, where the metadata reflects the fields of the record type that was originally declared:

\begin{shell}
; ModuleID = '../examples/Person.mod'
source_filename = "../examples/Person.mod"
target datalayout = "e-m:o-i64:64-i128:128-n32:64-S128"
target triple = "arm64-apple-darwin22.6.0"

define void @_t6Person3Set(ptr nocapture dereferenceable(16) %p) {
entry:
    %0 = getelementptr inbounds ptr, ptr %p, i32 0, i32 1
    store i64 18, ptr %0, align 8, !tbaa !0
    ret void
}

!0 = !{!"_t6Person6Person", !1, i64 0, !1, i64 8}
!1 = !{!"INTEGER", !2, i64 0}
!2 = !{!"Simple tinylang TBAA"}
\end{shell}

Now that we have learned how to generate TBAA metadata, we will explore a very similar topic in the next section: generating debug metadata.

























