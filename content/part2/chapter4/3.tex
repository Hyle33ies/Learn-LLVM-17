
We collect all the functions and global variables of a compilation unit in an LLVM module. To ease the IR generation process, we can wrap all the functions from the previous sections into a code generator class. To get a working compiler, we also need to define the target architecture for which we want to generate code, and also add the passes that emit the code. We will implement this in this and the next few chapters, starting with the code generator.

\mySubsubsection{4.3.1.}{Wrapping all in the code generator}

The IR module is the brace around all elements we generate for a compilation unit. At the global level, we iterate through the declarations at the module level, create global variables, and call the code generation for procedures. A global variable in tinylang is mapped to an instance of the llvm::GobalValue class. This mapping is saved in Globals and made available to the code generation for procedures:

\begin{cpp}
void CGModule::run(ModuleDeclaration *Mod) {
    for (auto *Decl : Mod->getDecls()) {
        if (auto *Var =
                llvm::dyn_cast<VariableDeclaration>(Decl)) {
            // Create global variables
            auto *V = new llvm::GlobalVariable(
                *M, convertType(Var->getType()),
                /*isConstant=*/false,
                llvm::GlobalValue::PrivateLinkage, nullptr,
                mangleName(Var));
            Globals[Var] = V;
        } else if (auto *Proc =
            llvm::dyn_cast<ProcedureDeclaration>(Decl)) {
            CGProcedure CGP(*this);
            CGP.run(Proc);
        }
    }
}
\end{cpp}

The module also holds the LLVMContext class and caches the most commonly used LLVM types. The latter ones need to be initialized, for example, for the 64-bit integer type:

\begin{cpp}
Int64Ty = llvm::Type::getInt64Ty(getLLVMCtx());
\end{cpp}

The CodeGenerator class initializes the LLVM IR module and calls the code generation for the module. Most importantly, this class must know for which target architecture we’d like to generate code. This information is passed in the llvm::TargetMachine class, which is set up in the driver:

\begin{cpp}
std::unique_ptr<llvm::Module>
CodeGenerator::run(ModuleDeclaration *Mod,
                   std::string FileName) {
    std::unique_ptr<llvm::Module> M =
        std::make_unique<llvm::Module>(FileName, Ctx);
    M->setTargetTriple(TM->getTargetTriple().getTriple());
    M->setDataLayout(TM->createDataLayout());
    CGModule CGM(M.get());
    CGM.run(Mod);
    return M;
}
\end{cpp}

For ease of use, we must also introduce a factory method for the code generator:

\begin{cpp}
CodeGenerator *
CodeGenerator::create(llvm::LLVMContext &Ctx,
                      llvm::TargetMachine *TM) {
    return new CodeGenerator(Ctx, TM);
}
\end{cpp}

The CodeGenerator class provides a small interface to create IR code, which is ideal for use in the compiler driver. Before we integrate it, we need to implement the support for machine code generation.

\mySubsubsection{4.3.2.}{Initializing the target machine class}

Now, only the target machine is missing. With the target machine, we define the CPU architecture we’d like to generate code for. For each CPU, there are features available that can be used to influence the code generation process. For example, a newer CPU of a CPU architecture family can support vector instructions. With features, we can toggle the use of vector instructions on or off. To support setting all these options from the command line, LLVM provides some supporting code. In the Driver class, we can add the following include variable:

\begin{cpp}
#include "llvm/CodeGen/CommandFlags.h"
\end{cpp}

This include variable adds common command-line options to our compiler driver. Many LLVM tools also use these command-line options, which have the benefit of providing a common interface to the user. Only the option to specify a target triple is missing. As this is very useful, we’ll add this ourselves:

\begin{cpp}
static llvm::cl::opt<std::string> MTriple(
    "mtriple",
    llvm::cl::desc("Override target triple for module"));
\end{cpp}

Let’s create the target machine:

\begin{enumerate}
\item
To display error messages, the name of the application must be passed to the function:

\begin{cpp}
llvm::TargetMachine *
createTargetMachine(const char *Argv0) {
\end{cpp}

\item
First, we must collect all the information provided by the command line. These are options for the code generator – that is, the name of the CPU and possible features that should be activated or deactivated, and the triple of the target:

\begin{cpp}
    llvm::Triple Triple = llvm::Triple(
        !MTriple.empty()
            ? llvm::Triple::normalize(MTriple)
            : llvm::sys::getDefaultTargetTriple());

    llvm::TargetOptions TargetOptions =
        codegen::InitTargetOptionsFromCodeGenFlags(Triple);
    std::string CPUStr = codegen::getCPUStr();
    std::string FeatureStr = codegen::getFeaturesStr();
\end{cpp}

\item
Then, we must look up the target in the target registry. If an error occurs, then we will display the error message and bail out. A possible error would be an unsupported triple specified by the user:

\begin{cpp}
    std::string Error;
    const llvm::Target *Target =
        llvm::TargetRegistry::lookupTarget(
         codegen::getMArch(), Triple, Error);

    if (!Target) {
        llvm::WithColor::error(llvm::errs(), Argv0) << Error;
        return nullptr;
    }
\end{cpp}

\item
With the help of the Target class, we can configure the target machine using all the known options requested by the user:

\begin{cpp}
    llvm::TargetMachine *TM = Target->createTargetMachine(
        Triple.getTriple(), CPUStr, FeatureStr,
        TargetOptions, std::optional<llvm::Reloc::Model>(
            codegen::getRelocModel()));
    return TM;
}
\end{cpp}

\end{enumerate}

With the target machine instance, we can generate IR code that targets a CPU architecture of our choice. What is missing is the translation to assembly text or the generation of object code files. We’ll add this support in the next section.

\mySubsubsection{4.3.3.}{Emitting assembler text and object code}

In LLVM, the IR code is run through a pipeline of passes. Each pass performs a single task, such as removing dead code. We’ll learn more about passes in Chapter 7, Optimizing IR. Outputting assembler code or an object file is implemented as a pass too. Let’s add basic support for it!

We need to include even more LLVM header files. First, we need the llvm::legacy::PassManager class to hold the passes to emit code to a file. We also want to be able to output LLVM IR code, so we also need a pass to emit this. Finally, we’ll use the llvm:: ToolOutputFile class for the file operations:

\begin{cpp}
#include "llvm/IR/IRPrintingPasses.h"
#include "llvm/IR/LegacyPassManager.h"
#include "llvm/MC/TargetRegistry.h"
#include "llvm/Pass.h"
#include "llvm/Support/ToolOutputFile.h"
\end{cpp}

Another command-line option for outputting LLVM IR is also needed:

\begin{cpp}
static llvm::cl::opt<bool> EmitLLVM(
    "emit-llvm",
    llvm::cl::desc("Emit IR code instead of assembler"),
    llvm::cl::init(false));
\end{cpp}

Finally, we want to be able to give the output file a name:

\begin{cpp}
static llvm::cl::opt<std::string>
    OutputFilename("o",
                   llvm::cl::desc("Output filename"),
                   llvm::cl::value_desc("filename"));
\end{cpp}

The first task in the new emit() method is to deal with the name of the output file if it’s not given by the user on the command line. If the input is read from stdin, indicated by the use of the minus symbol, -, then we output the result to stdout. The ToolOutputFile class knows how to handle the special filename, -:

\begin{cpp}
bool emit(StringRef Argv0, llvm::Module *M,
          llvm::TargetMachine *TM,
          StringRef InputFilename) {
    CodeGenFileType FileType = codegen::getFileType();
    if (OutputFilename.empty()) {
        if (InputFilename == "-") {
            OutputFilename = "-";
        }
\end{cpp}

Otherwise, we drop a possible extension of the input filename and append .ll, .s, or .o as an extension, depending on the command-line options given by the user. The FileType option is defined in the llvm/CodeGen/CommandFlags.inc header file, which we included earlier. This option doesn’t support emitting IR code, so we’ve added the new–emit-llvm option, which only takes effect if it’s used together with the assembly file type:

\begin{cpp}
    else {
        if (InputFilename.endswith(".mod"))
            OutputFilename =
                InputFilename.drop_back(4).str();
        else
            OutputFilename = InputFilename.str();
        switch (FileType) {
            case CGFT_AssemblyFile:
                OutputFilename.append(EmitLLVM ? ".ll" : ".s");
                break;
            case CGFT_ObjectFile:
                OutputFilename.append(".o");
                break;
            case CGFT_Null:
                OutputFilename.append(".null");
                break;
        }
    }
}
\end{cpp}

Some platforms distinguish between text and binary files, so we have to provide the right open flags when opening the output file:

\begin{cpp}
std::error_code EC;
sys::fs::OpenFlags OpenFlags = sys::fs::OF_None;
if (FileType == CGFT_AssemblyFile)
    OpenFlags |= sys::fs::OF_TextWithCRLF;
auto Out = std::make_unique<llvm::ToolOutputFile>(
    OutputFilename, EC, OpenFlags);
if (EC) {
    WithColor::error(llvm::errs(), Argv0)
        << EC.message() << '\n';
    return false;
}
\end{cpp}

Now, we can add the required passes to PassManager. The TargetMachine class has a utility method that adds the requested classes. Therefore, we only need to check if the user requests to output the LLVM IR code:

\begin{cpp}
    legacy::PassManager PM;
    if (FileType == CGFT_AssemblyFile && EmitLLVM) {
        PM.add(createPrintModulePass(Out->os()));
    } else {
        if (TM->addPassesToEmitFile(PM, Out->os(), nullptr,
                                    FileType)) {
            WithColor::error(llvm::errs(), Argv0)
                << "No support for file type\n";
            return false;
        }
    }
\end{cpp}

With all this preparation done, emitting the file boils down to a single function call:

\begin{cpp}
PM.run(*M);
\end{cpp}

The ToolOutputFile class automatically deletes the file if we do not explicitly request that we want to keep it. This makes error handling easier as there are potentially many places where we need to handle errors and only one place is reached if everything goes well. We successfully emitted the code, so we want to keep the file:

\begin{cpp}
Out->keep();
\end{cpp}

Finally, we must report success to the caller:

\begin{cpp}
    return true;
}
\end{cpp}

Calling the emit() method with llvm::Module, which we created with a call to the CodeGenerator class, emits the code as requested.
Suppose you have the greatest common divisor algorithm in tinylang stored in the Gcd.mod file:

\begin{shell}
MODULE Gcd;

PROCEDURE GCD(a, b: INTEGER) : INTEGER;
VAR t: INTEGER;
BEGIN
    IF b = 0 THEN
        RETURN a;
    END;
    WHILE b # 0 DO
    t := a MOD b;
    a := b;
    b := t;
    END;
    RETURN a;
END GCD;

END Gcd.
\end{shell}

To translate this to the Gcd.o object file, type the following:

\begin{shell}
$ tinylang --filetype=obj Gcd.mod
\end{shell}

If you’d like to inspect the generated IR code directly on the screen, type the following:

\begin{shell}
$ tinylang --filetype=asm --emit-llvm -o - Gcd.mod
\end{shell}

With the current state of the implementation, it is not possible to create a complete program in tinylang. However, you can use a small C program called callgcd.c to test the generated object file. Note the use of the mangled name to call the GCD function:

\begin{cpp}
#include <stdio.h>

extern long _t3Gcd3GCD(long, long);

int main(int argc, char *argv[]) {
    printf("gcd(25, 20) = %ld\n", _t3Gcd3GCD(25, 20));
    printf("gcd(3, 5) = %ld\n", _t3Gcd3GCD(3, 5));
    printf("gcd(21, 28) = %ld\n", _t3Gcd3GCD(21, 28));
    return 0;
}
\end{cpp}

To compile and run the whole application with clang, type the following:

\begin{shell}
$ tinylang --filetype=obj Gcd.mod
$ clang callgcd.c Gcd.o -o gcd
$ gcd
\end{shell}

Let’s celebrate! At this point, we have created a complete compiler by reading the source language up and emitting assembler code or an object file.


















