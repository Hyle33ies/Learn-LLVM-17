Real programming brings up more challenges than the simple calc language from the previous chapter.
To have a look at the details, we will be using a tiny subset of Modula-2 in this and the following chapters. Modula-2 is well-designed and optionally supports generics and object-orientated programming (OOP). However, we are not going to create a complete Modula-2 compiler in this book. Therefore, we will call the subset tinylang.

Let’s begin with an example of what a program in tinylang looks like. The following function computes the greatest common divisor using the Euclidean algorithm:

\begin{shell}
MODULE Gcd;

PROCEDURE GCD(a, b: INTEGER) : INTEGER;
VAR t: INTEGER;
BEGIN
    IF b = 0 THEN
        RETURN a;
    END;
    WHILE b # 0 DO
        t := a MOD b;
        a := b;
        b := t;
    END;
    RETURN a;
END GCD;

END Gcd.
\end{shell}

Now that we have a feeling for how a program in the language looks, let’s take a quick tour of the tinylang subset’s grammar as used in this chapter. In the next few sections, we’ll use this grammar to derive the lexer and the parser from it:

\begin{shell}
compilationUnit
    : "MODULE" identifier ";" ( import )* block identifier "." ;
Import : ( "FROM" identifier )? "IMPORT" identList ";" ;
Block
    : ( declaration )* ( "BEGIN" statementSequence )? "END" ;
\end{shell}

A compilation unit in Modula-2 begins with the MODULE keyword, followed by the name of the module. The content of a module can have a list of imported modules, declarations, and a block containing statements that run at initialization time:

\begin{shell}
declaration
    : "CONST" ( constantDeclaration ";" )*
    | "VAR" ( variableDeclaration ";" )*
    | procedureDeclaration ";" ;
\end{shell}

A declaration introduces constants, variables, and procedures. The declaration of constants is prefixed with the CONST keyword. Similarly, variable declarations begin with the VAR keyword. The declaration of a constant is very simple:

\begin{shell}
constantDeclaration : identifier "=" expression ;
\end{shell}

The identifier is the name of the constant. The value is derived from an expression, which must be computable at compile time. The declaration of variables is a bit more complex:

\begin{shell}
variableDeclaration : identList ":" qualident ;
qualident : identifier ( "." identifier )* ;
identList : identifier ( "," identifier)* ;
\end{shell}

To be able to declare more than one variable in one go, a list of identifiers is used. The type name can potentially come from another module and is prefixed by the module name in this case. This is called a qualified identifier. A procedure requires the most details:

\begin{shell}
procedureDeclaration
    : "PROCEDURE" identifier ( formalParameters )? ";"
        block identifier ;
formalParameters
    : "(" ( formalParameterList )? ")" ( ":" qualident )? ;
formalParameterList
    : formalParameter (";" formalParameter )* ;
formalParameter : ( "VAR" )? identList ":" qualident ;
\end{shell}

The preceding code shows how constants, variables, and procedures are declared. Procedures can have parameters and a return type. Normal parameters are passed as values, and VAR parameters are passed by reference. The other part missing from the block rule is statementSequence, which is a list of single statements:

\begin{shell}
statementSequence
    : statement ( ";" statement )* ;
\end{shell}

A statement is delimited by a semicolon if it is followed by another statement. Again, only a subset of the Modula-2 statements is supported:

\begin{shell}
statement
    : qualident ( ":=" expression | ( "(" ( expList )? ")" )? )
    | ifStatement | whileStatement | "RETURN" ( expression )? ;
\end{shell}

The first part of this rule describes an assignment or a procedure call. A qualified identifier followed by := is an assignment. If it is followed by (, then it is a procedure call. The other statements are the usual control statements:

\begin{shell}
ifStatement
    : "IF" expression "THEN" statementSequence
        ( "ELSE" statementSequence )? "END" ;
\end{shell}

The IF statement also has a simplified syntax as it can only have a single ELSE block. With that statement, we can conditionally guard a statement:

\begin{shell}
whileStatement
    : "WHILE" expression "DO" statementSequence "END" ;
\end{shell}

The WHILE statement describes a loop that’s guarded by a condition. Together with the IF statement, this enables us to write simple algorithms in tinylang. Finally, the definition of an expression is missing:

\begin{shell}
expList
    : expression ( "," expression )* ;
expression
    : simpleExpression ( relation simpleExpression )? ;
relation
    : "=" | "#" | "<" | "<=" | ">" | ">=" ;
simpleExpression
    : ( "+" | "-" )? term ( addOperator term )* ;
addOperator
    : "+" | "-" | "OR" ;
term
    : factor ( mulOperator factor )* ;
mulOperator
    : "*" | "/" | "DIV" | "MOD" | "AND" ;
factor
    : integer_literal | "(" expression ")" | "NOT" factor
    | qualident ( "(" ( expList )? ")" )? ;
\end{shell}

The expression syntax is very similar to that of calc in the previous chapter. Only the INTEGER and BOOLEAN data types are supported.

Additionally, the identifier and integer\_literal tokens are used. An identifier is a name that begins with a letter or an underscore, followed by letters, digits, and underscores. An integer literal is either a sequence of decimal digits or a sequence of hexadecimal digits, followed by the letter H.

These are already a lot of rules, and we’re only covering a part of Modula-2! Nevertheless, it is possible to write small applications in this subset. Let’s implement a compiler for tinylang!

























