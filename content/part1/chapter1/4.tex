
The CMake system uses a project description in the CMakeLists.txt file. The top-level file is in the llvm directory, llvm/CMakeLists.txt. Other directories also have CMakeLists.txt files, which are recursively included during the generation process.

Based on the information provided in the project description, CMake checks which compilers are installed, detects libraries and symbols, and creates the build system files, for example, build.ninja or Makefile (depending on the chosen generator). It is also possible to define reusable modules, for example, a function to detect whether LLVM is installed. These scripts are placed in the special cmake directory (llvm/cmake), which is searched automatically during the generation process.

The build process can be customized with the definition of CMake variables. The command-line option –D is used to set a variable to a value. The variables are used in the CMake scripts. Variables defined by CMake itself are almost always prefixed with CMAKE\_ and these variables can be used in all projects. Variables defined by LLVM are prefixed with LLVM\_ but they can only be used if the project definition includes the use of LLVM.


\mySubsubsection{1.4.1.}{Variables defined by CMake}

Some variables are initialized with the value of environment variables. Most notable are CC and CXX, which define the C and C++ compilers to be used for building. CMake tries to locate a C and a C++ compiler automatically, using the current shell search path. It picks the first compiler found. If you have several compilers installed, for example, gcc and clang or different versions of clang, then this might not be the compiler you want for building LLVM.

Suppose you like to use clang17 as a C compiler and clang++17 as a C++ compiler. Then, you can invoke CMake in a Unix shell in the following way:

\begin{shell}
$ CC=clang17 CXX=clang++17 cmake –B build –S llvm
\end{shell}

This sets the value of the environment variables only for the invocation of cmake. If necessary, you can specify an absolute path for the compiler executables.

CC is the default value of the CMAKE\_C\_COMPILER CMake variable, and CXX is the default value of the CMAKE\_CXX\_COMPILER CMake variable. Instead of using the environment variables, you can set the CMake variables directly. This is equivalent to the preceding call:

\begin{shell}
$ cmake –DCMAKE_C_COMPILER=clang17 \
  -DCMAKE_CXX_COMPILER=clang++17 –B build –S llvm
\end{shell}

Other useful variables defined by CMake are as follows:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{Variable name} &
\textbf{Purpose} \\ \hline
\endfirsthead
%
\endhead
%
CMAKE\_INSTALL\_PREFIX &
\begin{tabular}[c]{@{}l@{}}This is a path prefix that is prepended to every path during\\ installation. The default is /usr/local on Unix and C:\textbackslash\\ Program Files\textbackslash{}\textless{}Project\textgreater on Windows. To install\\ LLVM in the /opt/llvm directory, you specify -DCMAKE\_\\ INSTALL\_PREFIX=/opt/llvm. The binaries are copied to /\\ opt/llvm/bin, library files to /opt/llvm/lib, and so on.\end{tabular} \\ \hline
CMAKE\_BUILD\_TYPE &
\begin{tabular}[c]{@{}l@{}}Different types of build require different settings. For example, a\\ debug build needs to specify options to generate debug symbols\\ and usually link against debug versions of system libraries.\\ In contrast, a release build uses optimization flags and links\\ against production versions of libraries. This variable is only\\ used for build systems that can only handle one build type, for\\ example, Ninja or Make. For IDE build systems, all variants\\ are generated and you have to use the mechanism of the IDE\\ to switch between build types. Possible values are as follows:\\ DEBUG: build with debug symbols\\ RELEASE: build with optimization for speed\\ RELWITHDEBINFO: release build with debug symbols\\ MINSIZEREL: build with optimization for size\\ The default build type is taken from the CMAKE\_BUILD\_TYPE\\ environment variable. If this variable is not set, then the default\\ depends on the used toolchain and is often empty. In order to\\ generate build files for a release build, you specify -DCMAKE\_\\ BUILD\_TYPE=RELEASE.\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}CMAKE\_C\_FLAGS \\ CMAKE\_CXX\_FLAGS\end{tabular} &
\begin{tabular}[c]{@{}l@{}}These are extra flags used when compiling C and C++ source files.\\ The initial values are taken from the CFLAGS and CXXFLAGS\\ environment variables, which can be used as an alternative.\end{tabular} \\ \hline
CMAKE\_MODULE\_PATH &
\begin{tabular}[c]{@{}l@{}}This specifies additional directories that are searched for CMake\\ modules. The specified directories are searched before the default\\ ones. The value is a semicolon-separated list of directories.\end{tabular} \\ \hline
PYTHON\_EXECUTABLE &
\begin{tabular}[c]{@{}l@{}}If the Python interpreter is not found or if the wrong one is\\ picked in case you have installed multiple versions, you can\\ set this variable to the path of the Python binary. This variable\\ only has an effect if the Python module of CMake is included\\ (which is the case for LLVM).\end{tabular} \\ \hline
\end{longtable}

\begin{center}
Table 1.1 - Additional useful variables provided by CMake
\end{center}

CMake provides built-in help for variables. The -{}-help-variable var option prints help for the var variable. For instance, you can type the following to get help for CMAKE\_BUILD\_TYPE:

\begin{shell}
$ cmake --help-variable CMAKE_BUILD_TYPE
\end{shell}

You can also list all variables with the following command:

\begin{shell}
$ cmake --help-variable-list
\end{shell}

This list is very long. You may want to pipe the output to more or a similar program.

\mySubsubsection{1.4.2.}{Using LLVM-defined build configuration variables}

The build configuration variables defined by LLVM work in the same way as those defined by CMake except that there is no built-in help. The most useful variables are found in the following tables, where they are divided into variables that are useful for first-time users installing LLVM, and also variables for more advanced LLVM users.

Variables useful for first-time users installing LLVM

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{variable name} &
\textbf{Purpose} \\ \hline
\endfirsthead
%
\endhead
%
LLVM\_TARGETS\_TO\_BUILD &
\begin{tabular}[c]{@{}l@{}}LLVM supports code generation for different CPU\\ architectures. By default, all these targets are built. Use this\\ variable to specify the list of targets to build, separated by\\ semicolons. The current targets are AArch64, AMDGPU,\\ ARM, AVR, BPF, Hexagon, Lanai, LoongArch,\\ Mips, MSP430, NVPTX, PowerPC, RISCV, Sparc,\\ SystemZ, VE, WebAssembly, X86, and XCore.\\ all can be used as shorthand for all targets. The names\\ are case-sensitive. To only enable the PowerPC and the\\ System Z target, you specify -DLLVM\_TARGETS\_TO\_\\ BUILD="PowerPC;SystemZ".\end{tabular} \\ \hline
LLVM\_EXPERIMENTAL\_TARGETS\_TO\_BUILD &
\begin{tabular}[c]{@{}l@{}}In addition to the official targets, the LLVM source tree\\ also contains experimental targets. These targets are\\ under development and often do not yet support the full\\ functionality of a backend. The current list of experimental\\ targets is ARC, CSKY, DirectX, M68k, SPIRV, and\\ Xtensa. To build the M68k target, you specify -D\\ LLVM\_EXPERIMENTAL\_TARGETS\_TO\_BUILD=M68k.\end{tabular} \\ \hline
LLVM\_ENABLE\_PROJECTS &
\begin{tabular}[c]{@{}l@{}}This is a list of the projects you want to build, separated\\ by semicolons. The source for the projects must be on the\\ same level as the llvm directory (side-by-side layout). The\\ current list is bolt, clang, clang-tools-extra,\\ compiler-rt, cross-project-tests, libc,\\ libclc, lld, lldb, mlir, openmp, polly, and\\ pstl. all can be used as shorthand for all projects in\\ this list. Additionally, you can specify the flang project\\ here. Due to some special build requirements, it is not\\ yet part of the all list.\\ To build clang and bolt together with LLVM, you\\ specify -DLLVM\_ENABLE\_PROJECT="clang;bolt".\end{tabular} \\ \hline
\end{longtable}

\begin{center}
Table 1.2 - Useful variables for first-time LLVM users
\end{center}

Variables for advanced users of LLVM


% Please add the following required packages to your document preamble:
% \usepackage[normalem]{ulem}
% \useunder{\uline}{\ul}{}
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{variable name} &
\textbf{Purpose} \\ \hline
\endfirsthead
%
\endhead
%
LLVM\_ENABLE\_ASSERTIONS &
\begin{tabular}[c]{@{}l@{}}If set to ON, then assertion checks are enabled. These\\ checks help to find errors and are very useful during\\ development. The default value is ON for a DEBUG build\\ and otherwise OFF. To turn assertion checks on (e.g. for\\ a RELEASE build), you specify –DLLVM\_ENABLE\_\\ ASSERTIONS=ON.\end{tabular} \\ \hline
LLVM\_ENABLE\_EXPENSIVE\_CHECKS &
\begin{tabular}[c]{@{}l@{}}This enables some expensive checks that can really slow\\ down compilation speed or consume large amounts of\\ memory. The default value is OFF. To turn these checks\\ on, you specify -DLLVM\_ENABLE\_EXPENSIVE\_\\ CHECKS=ON.\end{tabular} \\ \hline
LLVM\_APPEND\_VC\_REV &
\begin{tabular}[c]{@{}l@{}}LLVM tools such as llc display the LLVM version they\\ are based on besides other information if the –version\\ command-line option is given. This version information\\ is based on the LLVM\_REVISION C macro. By default,\\ not only the LLVM version but also the current Git hash\\ is part of the version information. This is handy in case\\ you are following the development of the master branch\\ because it makes clear on which Git commit the tool is\\ based. If not needed, then this can be turned off with –\\ DLLVM\_APPEND\_VC\_REV=OFF.\end{tabular} \\ \hline
LLVM\_ENABLE\_THREADS &
\begin{tabular}[c]{@{}l@{}}LLVM automatically includes thread support if a threading\\ library is detected (usually the pthreads library). Further,\\ LLVM assumes in this case that the compiler supports\\ TLS (thread-local storage). If you don’t want thread\\ support or your compiler does not support TLS, then you\\ can turn it off with -DLLVM\_ENABLE\_THREADS=OFF.\end{tabular} \\ \hline
LLVM\_ENABLE\_EH &
\begin{tabular}[c]{@{}l@{}}The LLVM projects do not use C++ exception handling\\ and therefore turn exception support off by default. This\\ setting can be incompatible with other libraries your\\ project is linking with. If needed, you can enable exception\\ support by specifying –DLLVM\_ENABLE\_EH=ON.\end{tabular} \\ \hline
LLVM\_ENABLE\_RTTI &
\begin{tabular}[c]{@{}l@{}}LLVM uses a lightweight, self-build system for runtime type\\ information. The generation of C++ RTTI is turned off by\\ default. Like the exception handling support, this may be\\ incompatible with other libraries. To turn generation of\\ C++ RTTI on, you specify –DLLVM\_ENABLE\_RTTI=ON.\end{tabular} \\ \hline
LLVM\_ENABLE\_WARNINGS &
\begin{tabular}[c]{@{}l@{}}Compiling LLVM should generate no warning messages if\\ possible. The option to print warning messages is therefore\\ turned on by default. To turn it off, you specify –DLLVM\_\\ ENABLE\_WARNINGS=OFF.\end{tabular} \\ \hline
LLVM\_ENABLE\_PEDANTIC &
\begin{tabular}[c]{@{}l@{}}The LLVM source should be C/C++ language standard\\ conforming; hence, pedantic checking of the source is\\ enabled by default. If possible, compiler-specific extensions\\ are also disabled. To reverse this setting, you specify –\\ DLLVM\_ENABLE\_PEDANTIC=OFF.\end{tabular} \\ \hline
LLVM\_ENABLE\_WERROR &
\begin{tabular}[c]{@{}l@{}}If set to ON, then all warnings are treated as errors –\\ the compilation aborts as soon as warnings are found.\\ It helps to find all remaining warnings in the source.\\ By default, it is turned off. To turn it on, you specify –\\ DLLVM\_ENABLE\_WERROR=ON.\end{tabular} \\ \hline
LLVM\_OPTIMIZED\_TABLEGEN &
\begin{tabular}[c]{@{}l@{}}Usually, the tablegen tool is built with the same options\\ as all other parts of LLVM. At the same time, tablegen is\\ used to generate large parts of the code generator. As a\\ result, tablegen is much slower in a debug build, increasing\\ the compile time noticeably. If this option is set to ON,\\ then tablegen is compiled with optimization turned on\\ even for a debug build, possibly reducing compile time.\\ The default is OFF. To turn it on, you specify –DLLVM\_\\ OPTIMIZED\_TABLEGEN=ON.\end{tabular} \\ \hline
LLVM\_USE\_SPLIT\_DWARF &
\begin{tabular}[c]{@{}l@{}}If the build compiler is gcc or clang, then turning on\\ this option will instruct the compiler to generate the\\ DWARF debug information in a separate file. The reduced\\ size of the object files reduces the link time of debug\\ builds significantly. The default is OFF. To turn it on, you\\ specify -LLVM\_USE\_SPLIT\_DWARF=ON.\end{tabular} \\ \hline
\end{longtable}

\begin{center}
Table 1.3 - Useful variables for advanced LLVM users
\end{center}

\begin{myNotic}{Note}
LLVM defines many more CMake variables. You can find the complete list in the LLVM documentation about CMake \url{https://releases.llvm.org/17.0.1/docs/CMake.   html#llvm-specific-variables}. The preceding list contains only the ones you are most likely to need.
\end{myNotic}
















