
Implementing the rules of the calling convention is an important part of lowering the LLVM intermediate representation (IR) to machine code. The basic rules can be defined in the target description. Let’s have a look.

Most calling conventions follow a basic pattern: they define a subset of registers for parameter passing. If this subset is not exhausted, the next parameter is passed in the next free register. If there is no free register, then the value is passed on the stack. This can be realized by looping over the parameters and deciding how to pass each parameter to the called function while keeping track of the used registers. In LLVM, this loop is implemented inside the framework, and the state is held in a class called CCState. Furthermore, the rules are defined in the target description.

The rules are given as a sequence of conditions. If the condition holds, then an action is executed. Depending on the outcome of that action, either a place for the parameter is found, or the next condition is evaluated. For example, 32-bit integers are passed in a register. The condition is the type check, and the action is the assignment of a register to this parameter. In the target description, this is written as follows:

\begin{shell}
CCIfType<[i32],
        CCAssignToReg<[R2, R3, R4, R5, R6, R7, R8, R9]>>,
\end{shell}

Of course, if the called function has more than eight parameters, then the register list will be exhausted, and the action will fail. The remaining parameters are passed on the stack, and we can specify this as the next action:

\begin{shell}
CCAssignToStack<4, 4>
\end{shell}

The first parameter is the size of a stack slot in bytes, while the second is the alignment. Since it is a catch-all rule, no condition is used.

\mySubsubsection{12.1.1.}{Implementing the rules of the calling convention}

For a calling convention, there are also more predefined conditions and actions to note. For example, CCIfInReg checks if the argument is marked with the inreg attribute, and CCIfVarArg evaluates to true if the function has a variable argument list. The CCPromoteToType action promotes the type of the argument to a larger one, and the CCPassIndirect action indicates that the parameter value should be stored on the stack and that a pointer to that storage is passed as a normal argument. All of the predefined conditions and actions can be referenced within llvm/include/llvm/ Target/TargetCallingConv.td.

Both the parameters and the return value are defined in this way. We will put the definition into the M88kCallingConv.td file:

\begin{enumerate}
\item
First, we must define the rules for the parameters. To simplify the coding, we’ll only consider 32-bit values:

\begin{cpp}
def CC_M88k : CallingConv<[
    CCIfType<[i8, i16], CCPromoteToType<i32>>,
    CCIfType<[i32,f32],
        CCAssignToReg<[R2, R3, R4, R5, R6, R7, R8, R9]>>,
    CCAssignToStack<4, 4>
]>;
\end{cpp}

\item
After that, we must define the rules for return values:

\begin{cpp}
def RetCC_M88k : CallingConv<[
    CCIfType<[i32], CCAssignToReg<[R2]>>
]>;
\end{cpp}

\item
Finally, the sequence of callee saved registers must be defined. Note that we use the sequence operator to generate a sequence of registers, instead of writing them down:

\begin{cpp}
def CSR_M88k :
    CalleeSavedRegs<(add R1, R30,
        (sequence "R%d", 25, 14))>;
\end{cpp}
\end{enumerate}

The benefit of defining the rules for the calling convention in the target description is that they can be reused for various instruction selection methods. We’ll look at instruction selection via the selection DAG next.




