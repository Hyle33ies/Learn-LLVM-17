

Creating machine instructions from the IR is a very important task in the backend. One common way to implement it is to utilize a DAG:

\begin{enumerate}
\item
First, we must create a DAG from the IR. A node of the DAG represents an operation and the edges model control and data flow dependencies.

\item
Next, we must loop over the DAG and legalize the types and operations. Legalization means that we only use types and operations that are supported by the hardware. This requires us to create a configuration that tells the framework how to deal with non-legal types and operations. For instance, a 64-bit value could be split into two 32-bit values, the multiplication of two 64-bit values could be changed to a library call, and a complex operation such as count population could be expanded into a sequence of simpler operations for calculating this value.

\item
After, pattern matching is utilized to match nodes in the DAG and replace them with machine instructions. We encountered such a pattern in the previous chapter.

\item
Finally, an instruction scheduler reorders the machine instructions into a more performant order.
\end{enumerate}

This is just a high-level description of the instruction selection process via the selection DAG. If you are interested in more details, you can find it in the The LLVM Target-Independent Code Generator user guide at \url{https://llvm.org/docs/CodeGenerator.html#selectiondaginstruction-selection-process}.

Furthermore, all backends in LLVM implement the selection DAG. The main advantage is that it generates performant code. However, this comes at a cost: creating the DAG is expensive, and it slows down compilation speed. Therefore, this has prompted LLVM developers to look for alternative and more desirable approaches. Some targets implement instruction selection via FastISel, which is only used for non-optimized code. It can quickly generate code, but the generated code is inferior to the one generated by the selection DAG method. In addition, it adds a whole new instruction selection method, which doubles the testing effort. Another method is also used for instruction selection called global instruction selection, which we’ll examine later in the Global instruction selection section.

In this chapter, we aim to implement enough of the backend to lower a simple IR function, like this:

\begin{cpp}
define i32 @f1(i32 %a, i32 %b) {
    %res = and i32 %a, %b
    ret i32 %res
}
\end{cpp}

Moreover, for a real backend, much more code is needed, and we must point out what needs to be added for greater functionality.

To implement instruction selection via the selection DAG, we need to create two new classes: M88kISelLowering and M88kDAGToDAGISel. The former class is used to customize the DAG, for example, by defining which types are legal. It also contains the code to support the lowering of functions and function calls. The latter class performs DAG transformations, and the implementation is mostly generated from the target description.

There are several classes within the backend that we will be adding implementation to, and Figure 12.1 depicts the high-level relationship between the primary classes that we will be developing further:

\myGraphic{1.0}{content/part4/chapter12/images/1.png}{Figure 12.1 – Relationship between the main classes}

\mySubsubsection{12.2.1.}{Implementing DAG lowering – handling legal types and setting operations}

Let’s implement the M88kISelLowering class, which is stored in M88kISelLowering.cpp file, first. The constructor configures the legal types and operations:

\begin{enumerate}
\item
The constructor takes references to the TargetMachine and M88kSubtarget classes as parameters. The TargetMachine class is responsible for the general configuration of the target, for example, which passes need to run. An LLVM backend usually targets a CPU family, and the M88kSubtarget class describes the characteristics of the chosen CPU. We’ll look at both classes later in this chapter:

\begin{cpp}
M88kTargetLowering::M88kTargetLowering(
    const TargetMachine &TM, const M88kSubtarget &STI)
    : TargetLowering(TM), Subtarget(STI) {
\end{cpp}

\item
The first action is to declare which machine value type uses which register class. Remember that the register classes are generated from the target description. Here, we only handle 32-bit values:

\begin{cpp}
    addRegisterClass(MVT::i32, &M88k::GPRRegClass);
\end{cpp}

\item
After adding all register classes, we must compute the derived properties of those register classes. We need to query the sub-target for register information, which is mostly generated from the target description:

\begin{cpp}
computeRegisterProperties(Subtarget.getRegisterInfo());
\end{cpp}

\item
Next, we must declare which register contains the stack pointer:

\begin{cpp}
setStackPointerRegisterToSaveRestore(M88k::R31);
\end{cpp}

\item
Boolean values are represented differently on different platforms. For our target, we will declare that a Boolean value is stored in bit 0; the other bits are cleared:

\begin{cpp}
setBooleanContents(ZeroOrOneBooleanContent);
\end{cpp}

\item
After, we set the alignment of functions. The minimal function alignment is the alignment that is required for correct execution. In addition, we give the preferred alignment:

\begin{cpp}
setMinFunctionAlignment(Align(4));
setPrefFunctionAlignment(Align(4));
\end{cpp}

\item
Finally, we declare which operations are legal. In the previous chapter, we only defined three logical instructions, and they are legal for 32-bit values:

\begin{cpp}
setOperationAction(ISD::AND, MVT::i32, Legal);
setOperationAction(ISD::OR, MVT::i32, Legal);
setOperationAction(ISD::XOR, MVT::i32, Legal);
\end{cpp}

\item
There are a couple of other actions we can use besides Legal. Promote widens the type, Expand replaces the operation with other operations, LibCall lowers the operation to a library call, and Custom calls the LowerOperation() hook method, which lets you implement your own custom handling. For example, in the M88k architecture, there is no count population instruction, so we request that this operation be expanded into other operations:

\begin{cpp}
    setOperationAction(ISD::CTPOP, MVT::i32, Expand);
}
\end{cpp}
\end{enumerate}

Now, let’s review some points to emphasize the connection between the definitions we made so far. In the target description mentioned in the M88kInstrInfo.td file, we defined a machine instruction with the and mnemonic, and we also attached a pattern to it. If we expand the AND multiclass record, and only look at the instruction using three registers, we get the TableGen definition:

\begin{cpp}
let isCommutable = 1 in
    def ANDrr : F_LR<0b01000, Func, /*comp=*/0b0, "and",
                    [(set i32:$rd,
                        (and GPROpnd:$rs1, GPROpnd:$rs2))]>;
\end{cpp}

The "and" string is the mnemonic of the instruction. In C++ source code, we use M88k::ANDrr to refer to this instruction. Inside the pattern, the DAG and node type is used. In C++, it is named ISD::AND, and we used it in the call to the setOperationAction() method. During instruction selection, a DAG node of the and type is replaced by the M88k::ANDrr instruction if the pattern matches, which includes the input operands. Thus, when we develop instruction selection, the most important task is for us to define the correct legalization actions and attach the patterns to the instruction definitions.

\mySubsubsection{12.2.2.}{Implementing DAG lowering – lowering formal arguments}

Let’s turn to another important task performed by the M88kISelLowering class. We defined the rules for the calling convention in the previous section, but we also need to map the physical registers and memory locations to virtual registers used in the DAG. For arguments, this is done in the LowerFormalArguments() method; return values are handled in the LowerReturn() method. First, we must handle the arguments:

\begin{itemize}
\item
We’ll begin by including the generated source:

\begin{cpp}
#include "M88kGenCallingConv.inc"
\end{cpp}

\item
The LowerFormalArguments() method takes several parameters. The SDValue class denotes a value associated with a DAG node and is often used when dealing with the DAG. The first parameter, Chain, represents the control flow, and the possible updated Chain is also the return value of the method. The CallConv parameter identifies the used calling convention, and IsVarArg is set to true if a variable argument list is part of the parameters. The arguments that need to be handled are passed in the Ins parameter, together with their location in the DL parameter. The DAG parameter gives us access to the SelectionDAG class. Lastly, the result of the mapping will be stored in the InVals vector argument:

\begin{cpp}
SDValue M88kTargetLowering::LowerFormalArguments(
    SDValue Chain, CallingConv::ID CallConv,
    bool IsVarArg,
    const SmallVectorImpl<ISD::InputArg> &Ins,
    const SDLoc &DL, SelectionDAG &DAG,
    SmallVectorImpl<SDValue> &InVals) const {
\end{cpp}

\item
Our first action is to retrieve references to the machine function and the machine register information:

\begin{cpp}
    MachineFunction &MF = DAG.getMachineFunction();
    MachineRegisterInfo &MRI = MF.getRegInfo();
\end{cpp}

\item
Next, we must call the generated code. We need to instantiate an object of the CCState class. The CC\_M88k parameter value that’s used in the call to the AnalyzeFormalArguments() method is the name of the calling convention we used in the target description. The result is stored in the ArgLocs vector:

\begin{cpp}
    SmallVector<CCValAssign, 16> ArgLocs;
    CCState CCInfo(CallConv, IsVarArg, MF, ArgLocs,
        *DAG.getContext());
    CCInfo.AnalyzeFormalArguments(Ins, CC_M88k);
\end{cpp}

\item
Once the locations of the arguments have been determined, we need to map them to the DAG. Therefore, we must loop over all locations:

\begin{cpp}
    for (unsigned I = 0, E = ArgLocs.size(); I != E; ++I) {
        SDValue ArgValue;
        CCValAssign &VA = ArgLocs[I];
        EVT LocVT = VA.getLocVT();
\end{cpp}

\item
The mapping depends on the determined location. First, we handle arguments assigned to registers. The goal is to copy the physical register to a virtual register. To do so, we need to determine the correct register class. Since we’re only handling 32-bit values, it is easy to do this:

\begin{cpp}
        if (VA.isRegLoc()) {
            const TargetRegisterClass *RC;
            switch (LocVT.getSimpleVT().SimpleTy) {
            default:
                llvm_unreachable("Unexpected argument type");
            case MVT::i32:
                RC = &M88k::GPRRegClass;
                break;
            }
\end{cpp}

\item
With the register class stored in the RC variable, we can create the virtual register and copy the value. We also need to declare the physical register as a live-in:

\begin{cpp}
            Register VReg = MRI.createVirtualRegister(RC);
            MRI.addLiveIn(VA.getLocReg(), VReg);
            ArgValue =
                DAG.getCopyFromReg(Chain, DL, VReg, LocVT);
\end{cpp}

\item
In the definition of the calling convention, we added the rule that 8-bit and 16-bit values should be promoted to 32-bit, and we need to ensure the promotion here. To do so, a DAG node must be inserted, which makes sure that the value is promoted. After, the value is truncated to the right size. Note that we pass the value of ArgValue as an operand to the DAG node and store the result in the same variable:

\begin{cpp}
            if (VA.getLocInfo() == CCValAssign::SExt)
                ArgValue = DAG.getNode(
                    ISD::AssertSext, DL, LocVT, ArgValue,
                    DAG.getValueType(VA.getValVT()));
            else if (VA.getLocInfo() == CCValAssign::ZExt)
                ArgValue = DAG.getNode(
                    ISD::AssertZext, DL, LocVT, ArgValue,
                    DAG.getValueType(VA.getValVT()));
            if (VA.getLocInfo() != CCValAssign::Full)
                ArgValue = DAG.getNode(ISD::TRUNCATE, DL,
                                        VA.getValVT(), ArgValue);
\end{cpp}

\item
Lastly, we finish handling the register arguments by adding the DAG node to the result vector:

\begin{cpp}
            InVals.push_back(ArgValue);
        }
\end{cpp}

\item
The other possible location for a parameter is on the stack. However, we didn’t define any load and store instructions, so we cannot handle this case yet. This ends the loop over all argument locations:

\begin{cpp}
        } else {
            llvm_unreachable("Not implemented");
        }
    }
\end{cpp}

\item
After that, we may need to add code to handle variable argument lists. Again, we have added some code to remind us that we have not implemented it:

\begin{cpp}
    assert(!IsVarArg && "Not implemented");
\end{cpp}

\item
Finally, we must return the Chain argument:

\begin{cpp}
    return Chain;
}
\end{cpp}
\end{itemize}

\mySubsubsection{12.2.3.}{Implementing DAG lowering – lowering return values}

The return values are handled similarly. However, we must extend the target description for them. First, we need to define a new DAG node type called RET\_GLUE. This DAG node type is used to glue the return values together, which prevents them from being rearranged, for example, by the instruction scheduler. The definition in M88kInstrInfo.td is as follows:

\begin{cpp}
def retglue : SDNode<"M88kISD::RET_GLUE", SDTNone,
                [SDNPHasChain, SDNPOptInGlue, SDNPVariadic]>;
\end{cpp}

In the same file, we also define a pseudo-instruction to represent a return from a function call, which will be selected for a RET\_GLUE node:

\begin{cpp}
let isReturn = 1, isTerminator = 1, isBarrier = 1,
        AsmString = "RET" in
    def RET : Pseudo<(outs), (ins), [(retglue)]>;
\end{cpp}

We will expand this pseudo-instruction when we generate the output.

With these definitions in place, we can implement the LowerReturn() method:

\begin{enumerate}
\item
The parameters are the same as for LowerFormalArguments(), only the order is slightly different:

\begin{cpp}
SDValue M88kTargetLowering::LowerReturn(
    SDValue Chain, CallingConv::ID CallConv,
    bool IsVarArg,
    const SmallVectorImpl<ISD::OutputArg> &Outs,
    const SmallVectorImpl<SDValue> &OutVals,
    const SDLoc &DL, SelectionDAG &DAG) const {
\end{cpp}

\item
First, we call the generated code, this time using the RetCC\_M88k calling convention:

\begin{cpp}
    SmallVector<CCValAssign, 16> RetLocs;
    CCState RetCCInfo(CallConv, IsVarArg,
                        DAG.getMachineFunction(), RetLocs,
                        *DAG.getContext());
    RetCCInfo.AnalyzeReturn(Outs, RetCC_M88k);
\end{cpp}

\item
Then, we loop over the locations again. With the simple definition of the calling convention we currently have, this loop will be executed once at most. However, this would change if we would add support for returning 64-bit values, which need to be returned in two registers:

\begin{cpp}
    SDValue Glue;
    SmallVector<SDValue, 4> RetOps(1, Chain);
    for (unsigned I = 0, E = RetLocs.size(); I != E; ++I) {
        CCValAssign &VA = RetLocs[I];
\end{cpp}

\item
After, we copy the return values into the physical registers assigned to the return value. This is mostly similar to handling the arguments, with the exception that the values are glued together using the Glue variable:

\begin{cpp}
    Register Reg = VA.getLocReg();
    Chain = DAG.getCopyToReg(Chain, DL, Reg, OutVals[I], Glue);
    Glue = Chain.getValue(1);
    RetOps.push_back(
        DAG.getRegister(Reg, VA.getLocVT()));
}
\end{cpp}

\item
The return value is the chain and the glued register copy operations. The latter is only returned if there is a value to return:

\begin{cpp}
    RetOps[0] = Chain;
    if (Glue.getNode())
        RetOps.push_back(Glue);
\end{cpp}

\item
Finally, we construct a DAG node of the RET\_GLUE type, passing in the necessary values:

\begin{cpp}
    return DAG.getNode(M88kISD::RET_GLUE, DL, MVT::Other,
                        RetOps);
}
\end{cpp}
\end{enumerate}

Congratulations! With these definitions, the foundation has been laid for instruction selection.

\mySubsubsection{12.2.4.}{Implementing DAG-to-DAG transformations within instruction selection}

One crucial part is still missing: we need to define the pass that performs the DAG transformations defined in the target descriptions. The class is called M88kDAGToDAGISel and is stored in the M88kISelDAGToDAG.cpp file. Most of the class is generated, but we still need to add some code:

\begin{enumerate}
\item
We’ll begin by defining the debug type and providing a descriptive name for the pass:

\begin{cpp}
#define DEBUG_TYPE "m88k-isel"
#define PASS_NAME
            "M88k DAG->DAG Pattern Instruction Selection"
\end{cpp}

\item
Then, we must declare the class inside an anonymous namespace. We will only override the Select() method; the other code is generated and included in the body of the class:

\begin{cpp}
class M88kDAGToDAGISel : public SelectionDAGISel {
public:
    static char ID;

    M88kDAGToDAGISel(M88kTargetMachine &TM,
                     CodeGenOpt::Level OptLevel)
        : SelectionDAGISel(ID, TM, OptLevel) {}

    void Select(SDNode *Node) override;

#include "M88kGenDAGISel.inc"
};
} // end anonymous namespace
\end{cpp}

\item
After, we must add the code to initialize the pass. The LLVM backends still use the legacy pass manager, and the setup differs from the pass manager used for IR transformations. The static member ID value is used to identify the pass. Initializing the pass can be implemented using the INITIALIZE\_PASS macro, which expands to C++ code. We must also add a factory method to create an instance of the pass:

\begin{cpp}
char M88kDAGToDAGISel::ID = 0;

INITIALIZE_PASS(M88kDAGToDAGISel, DEBUG_TYPE, PASS_NAME,
                false, false)

FunctionPass *
llvm::createM88kISelDag(M88kTargetMachine &TM,
                        CodeGenOpt::Level OptLevel) {
    return new M88kDAGToDAGISel(TM, OptLevel);
}
\end{cpp}

\item
Finally, we must implement the Select() method. For now, we only call the generated code. However, if we encounter a complex transformation that we cannot express as a DAG pattern, then we can add our own code to perform the transformation before calling the generated code:

\begin{cpp}
void M88kDAGToDAGISel::Select(SDNode *Node) {
    SelectCode(Node);
}
\end{cpp}
\end{enumerate}

With that, we have implemented the instruction selection. However, we still need to add some support classes before we can do the first test. We’ll look at those classes in the next few sections.
















