Implementing the disassembler is optional. However, the implementation does not require too much effort, and generating the disassembler table may catch encoding errors that are not checked by the other generators. The disassembler lives in the M88kDisassembler.cpp file, found in the Disassembler subdirectory:

\begin{enumerate}
\item
We begin the implementation by defining a debug type and the DecodeStatus type. Both are required for the generated code:

\begin{cpp}
using namespace llvm;
#define DEBUG_TYPE "m88k-disassembler"
using DecodeStatus = MCDisassembler::DecodeStatus;
\end{cpp}

\item
The M88kDisassmbler class lives in an anonymous namespace. We only need to implement the getInstruction() method:

\begin{cpp}
namespace {
class M88kDisassembler : public MCDisassembler {
public:
    M88kDisassembler(const MCSubtargetInfo &STI,
                     MCContext &Ctx)
        : MCDisassembler(STI, Ctx) {}
    ~M88kDisassembler() override = default;

    DecodeStatus
    getInstruction(MCInst &instr, uint64_t &Size,
                    ArrayRef<uint8_t> Bytes,
                    uint64_t Address,
                    raw_ostream &CStream) const override;
};
} // end anonymous namespace
\end{cpp}

\item
We also need to provide a factory method, which will be registered in the target registry:

\begin{cpp}
static MCDisassembler *
createM88kDisassembler(const Target &T,
                        const MCSubtargetInfo &STI,
                        MCContext &Ctx) {
    return new M88kDisassembler(STI, Ctx);
}

extern "C" LLVM_EXTERNAL_VISIBILITY void
LLVMInitializeM88kDisassembler() {
    TargetRegistry::RegisterMCDisassembler(
        getTheM88kTarget(), createM88kDisassembler);
}
\end{cpp}

\item
The decodeGPRRegisterClass() function turns a register number into the register enum member generated by TableGen. This is the inverse operation of the M88kInstPrinter:: getMachineOpValue() method. Note that we specified the name of this function in the DecoderMethod field in the M88kRegisterOperand class:

\begin{cpp}
static const uint16_t GPRDecoderTable[] = {
    M88k::R0, M88k::R1, M88k::R2, M88k::R3,
    // …
};

static DecodeStatus
decodeGPRRegisterClass(MCInst &Inst, uint64_t RegNo,
                        uint64_t Address,
                        const void *Decoder) {
    if (RegNo > 31)
        return MCDisassembler::Fail;

    unsigned Register = GPRDecoderTable[RegNo];
    Inst.addOperand(MCOperand::createReg(Register));
    return MCDisassembler::Success;
}
\end{cpp}

\item
Then we include the generated disassembler tables:

\begin{cpp}
#include "M88kGenDisassemblerTables.inc"
\end{cpp}

\item
And finally, we decode the instruction. For this, we need to take the next four bytes of the Bytes array, create the instruction encoding from them, and call the decodeInstruction() generated function:

\begin{cpp}
DecodeStatus M88kDisassembler::getInstruction(
        MCInst &MI, uint64_t &Size, ArrayRef<uint8_t> Bytes,
        uint64_t Address, raw_ostream &CS) const {
    if (Bytes.size() < 4) {
        Size = 0;
        return MCDisassembler::Fail;
    }
    Size = 4;

    uint32_t Inst = 0;
    for (uint32_t I = 0; I < Size; ++I)
        Inst = (Inst << 8) | Bytes[I];

    if (decodeInstruction(DecoderTableM88k32, MI, Inst,
                          Address, this, STI) !=
        MCDisassembler::Success) {
        return MCDisassembler::Fail;
    }
    return MCDisassembler::Success;
}
\end{cpp}

\end{enumerate}

That is all that needs to be done for the disassembler. After compiling LLVM, you can test the functionality again with the llvm-mc tool:

\begin{shell}
$ echo "0xf4,0x22,0x40,0x03" | \
    bin/llvm-mc --triple m88k-openbsd –disassemble
          .text
          and %r1, %r2, %r3
\end{shell}

Moreover, we can now use the llvm-objdump tool to disassemble ELF files. However, for it to be really useful, we would need to add all instructions to the target description.


























































