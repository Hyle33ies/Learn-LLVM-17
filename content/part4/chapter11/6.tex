
The assembler parser is easy to implement, since LLVM provides a framework for it, and large parts are generated from the target description.

The ParseInstruction() method in our class is called when the framework detects that an instruction needs to be parsed. That method parses in input via the provided lexer and constructs a so-called operand vector. An operand can be a token such as an instruction mnemonic, a register name, or an immediate, or it can be category-specific to the target. For example, two operands are constructed from the jmp \%r2 input: a token operand for the mnemonic, and a register operand.

Then a generated matcher tries to match the operand vector against the instructions. If a match is found, then an instance of the MCInst class is created, which holds the parsed instruction. Otherwise, an error message is emitted. The advantage of this approach is that it automatically derives the matcher from the target description, without needing to handle all syntactical quirks.

However, we need to add a couple more support classes to make the assembler parser work. These additional classes are all stored in the MCTargetDesc directory.


\mySamllsection{Implementing the MCAsmInfo support class for the M88k Target}

Within this section, we explore implementing the first required class for the configuration of the assembler parser: the MCAsmInfo class:

\begin{enumerate}
\item
We need to set some customization parameters for the assembler parser. The MCAsmInfo base class (\url{https://github.com/llvm/llvm-project/blob/main/llvm/ include/llvm/MC/MCAsmInfo.h}) contains the common parameters. In addition, a subclass is created for each supported object file format; for example, the MCAsmInfoELF class (\url{https://github.com/llvm/llvm-project/blob/main/llvm/include/ llvm/MC/MCAsmInfoELF.h}). The reasoning behind it is that the system assemblers on systems using the same object file format share common characteristics because they must support similar features. Our target operating system is OpenBSD, and it uses the ELF file format, so we derive our own M88kMCAsmInfo class from the MCAsmInfoELF class. The declaration in the M88kMCAsmInfo.h file is as follows:

\begin{cpp}
namespace llvm {
class Triple;

class M88kMCAsmInfo : public MCAsmInfoELF {
public:
    explicit M88kMCAsmInfo(const Triple &TT);
};
\end{cpp}

\item
The implementation in the M88kMCAsmInfo.cpp file only sets a couple of default values. Two crucial settings at present are the system using big-endian mode and employing the | symbol for comments. The other settings are for code generation later:

\begin{cpp}
using namespace llvm;

M88kMCAsmInfo::M88kMCAsmInfo(const Triple &TT) {
    IsLittleEndian = false;
    UseDotAlignForAlignment = true;
    MinInstAlignment = 4;
    CommentString = "|"; // # as comment delimiter is only
                         // allowed at first column
    ZeroDirective = "\t.space\t";
    Data64bitsDirective = "\t.quad\t";
    UsesELFSectionDirectiveForBSS = true;
    SupportsDebugInformation = false;
    ExceptionsType = ExceptionHandling::SjLj;
}
\end{cpp}

Now we have completed the implementation for the MCAsmInfo class. The next class we will learn to implement helps us create a binary representation of the instructions within LLVM.
\end{enumerate}

\mySamllsection{Implementing the MCCodeEmitter support class for the M88k Target}

Internally in LLVM, an instruction is represented by an instance of the MCInst class. An instruction can be emitted as an assembler text or in binary into an object file. The M88kMCCodeEmitter class creates the binary representation of an instruction, while the M88kInstPrinter class emits the textual representation of it.

First, we will implement the M88kMCCodeEmitter class, which is stored in the M88kMCCodeEmitter.cpp file:

\begin{enumerate}
\item
Most of the class is generated by TableGen. Therefore, we only need to add some boilerplate code. Note that there is no corresponding header file; the prototype of the factory function will be added to the M88kMCTargetDesc.h file. It begins with setting up a statistic counter for the number of emitted instructions:

\begin{cpp}
using namespace llvm;
#define DEBUG_TYPE "mccodeemitter"
STATISTIC(MCNumEmitted,
          "Number of MC instructions emitted");
\end{cpp}

\item
The M88kMCCodeEmitter class lives in an anonymous namespace. We only need to implement the encodeInstruction() method, which is declared in the base class, and the getMachineOpValue() helper method. The other getBinaryCodeForInstr() method is generated by TableGen from the target description:

\begin{cpp}
namespace {
class M88kMCCodeEmitter : public MCCodeEmitter {
    const MCInstrInfo &MCII;
    MCContext &Ctx;

public:
    M88kMCCodeEmitter(const MCInstrInfo &MCII,
                      MCContext &Ctx)
    : MCII(MCII), Ctx(Ctx) {}

    ~M88kMCCodeEmitter() override = default;

    void encodeInstruction(
        const MCInst &MI, raw_ostream &OS,
        SmallVectorImpl<MCFixup> &Fixups,
        const MCSubtargetInfo &STI) const override;

    uint64_t getBinaryCodeForInstr(
        const MCInst &MI,
        SmallVectorImpl<MCFixup> &Fixups,
        const MCSubtargetInfo &STI) const;

    unsigned
    getMachineOpValue(const MCInst &MI,
                        const MCOperand &MO,
                        SmallVectorImpl<MCFixup> &Fixups,
                        const MCSubtargetInfo &STI) const;
};
} // end anonymous namespace
\end{cpp}

\item
The encodeInstruction() method just looks up the binary representation of the instruction, increments the statistic counter, and writes the bytes out in big-endian format. Remember that the instructions have a fixed size of 4 bytes, therefore we use the uint32\_t type on the endian stream:

\begin{cpp}
void M88kMCCodeEmitter::encodeInstruction(
        const MCInst &MI, raw_ostream &OS,
        SmallVectorImpl<MCFixup> &Fixups,
        const MCSubtargetInfo &STI) const {
    uint64_t Bits =
        getBinaryCodeForInstr(MI, Fixups, STI);
    ++MCNumEmitted;
    support::endian::write<uint32_t>(OS, Bits,
                                     support::big);
}
\end{cpp}

\item
The task of the getMachineOpValue() method is to return the binary representation of operands. In the target description, we defined the bit ranges where the registers used are stored in an instruction. Here, we compute the value, which is stored in these places. The method is called from the generated code. We only support two cases. For a register, the encoding of the register, which we defined in the target description, is returned. For an immediate, the immediate value is returned:

\begin{cpp}
unsigned M88kMCCodeEmitter::getMachineOpValue(
        const MCInst &MI, const MCOperand &MO,
        SmallVectorImpl<MCFixup> &Fixups,
        const MCSubtargetInfo &STI) const {
    if (MO.isReg())
        return Ctx.getRegisterInfo()->getEncodingValue(
            MO.getReg());
    if (MO.isImm())
        return static_cast<uint64_t>(MO.getImm());
    return 0;
}
\end{cpp}

\item
And last, we include the generated file and create a factory method for the class:

\begin{cpp}
#include "M88kGenMCCodeEmitter.inc"

MCCodeEmitter *
llvm::createM88kMCCodeEmitter(const MCInstrInfo &MCII,
                              MCContext &Ctx) {
    return new M88kMCCodeEmitter(MCII, Ctx);
}
\end{cpp}
\end{enumerate}

\mySamllsection{Implementing the instruction printer support class for the M88k Target}

The M88kInstPrinter class has a similar structure to the M88kMCCodeEmitter class. As mentioned previously, the InstPrinter class is responsible for emitting the textual representation of LLVM instructions. Most of the class is generated by TableGen, but we have to add support for printing the operands. The class is declared in the M88kInstPrinter.h header file. The implementation is in the M88kInstPrinter.cpp file:

\begin{enumerate}
\item
Letâ€™s begin with the header file. After including the required header files and declaring the llvm namespace, two forward references are declared to reduce the number of required includes:

\begin{cpp}
namespace llvm {
class MCAsmInfo;
class MCOperand;
\end{cpp}

\item
Besides the constructor, we only need to implement the printOperand() and printInst() methods. The other methods are generated by TableGen:

\begin{cpp}
class M88kInstPrinter : public MCInstPrinter {
public:
    M88kInstPrinter(const MCAsmInfo &MAI,
                    const MCInstrInfo &MII,
                    const MCRegisterInfo &MRI)
        : MCInstPrinter(MAI, MII, MRI) {}

    std::pair<const char *, uint64_t>
    getMnemonic(const MCInst *MI) override;
    void printInstruction(const MCInst *MI,
                            uint64_t Address,
                            const MCSubtargetInfo &STI,
                            raw_ostream &O);

    static const char *getRegisterName(MCRegister RegNo);

    void printOperand(const MCInst *MI, int OpNum,
                        const MCSubtargetInfo &STI,
                        raw_ostream &O);

    void printInst(const MCInst *MI, uint64_t Address,
                    StringRef Annot,
                    const MCSubtargetInfo &STI,
                    raw_ostream &O) override;
};
} // end namespace llvm
\end{cpp}

\item
The implementation lives in the M88kInstPrint.cpp file. After including the required header file and using the llvm namespace, the file with the generated C++ fragments is included:

\begin{cpp}
using namespace llvm;

#define DEBUG_TYPE "asm-printer"

#include "M88kGenAsmWriter.inc"
\end{cpp}

\item
The printOperand() method checks the type of the operand and emits either a register name or an immediate. The register name is looked up with the getRegisterName() generated method:

\begin{cpp}
void M88kInstPrinter::printOperand(
        const MCInst *MI, int OpNum,
        const MCSubtargetInfo &STI, raw_ostream &O) {
    const MCOperand &MO = MI->getOperand(OpNum);
    if (MO.isReg()) {
        if (!MO.getReg())
            O << '0';
        else
            O << '%' << getRegisterName(MO.getReg());
    } else if (MO.isImm())
        O << MO.getImm();
    else
        llvm_unreachable("Invalid operand");
}
\end{cpp}

\item
The printInst() method only calls the printInstruction() generated method to print the instruction, and after that, the printAnnotation() method to print possible annotations:

\begin{cpp}
void M88kInstPrinter::printInst(
        const MCInst *MI, uint64_t Address, StringRef Annot,
        const MCSubtargetInfo &STI, raw_ostream &O) {
    printInstruction(MI, Address, STI, O);
    printAnnotation(O, Annot);
}
\end{cpp}
\end{enumerate}

\mySamllsection{Implementing M88k-specific target descriptions}

In the M88kMCTargetDesc.cpp file, we need to make a couple of additions:

\begin{enumerate}
\item
First, we need a new factory method for the MCInstPrinter class and the MCAsmInfo class:

\begin{cpp}
static MCInstPrinter *createM88kMCInstPrinter(
        const Triple &T, unsigned SyntaxVariant,
        const MCAsmInfo &MAI, const MCInstrInfo &MII,
        const MCRegisterInfo &MRI) {
    return new M88kInstPrinter(MAI, MII, MRI);
}

static MCAsmInfo *
        createM88kMCAsmInfo(const MCRegisterInfo &MRI,
        const Triple &TT,
        const MCTargetOptions &Options) {
    return new M88kMCAsmInfo(TT);
}
\end{cpp}

\item
Finally, within the LLVMInitializeM88kTargetMC() function, we need to add the registration of the factory methods:

\begin{cpp}
extern "C" LLVM_EXTERNAL_VISIBILITY void
LLVMInitializeM88kTargetMC() {
    // â€¦
    TargetRegistry::RegisterMCAsmInfo(
        getTheM88kTarget(), createM88kMCAsmInfo);
    TargetRegistry::RegisterMCCodeEmitter(
        getTheM88kTarget(), createM88kMCCodeEmitter);
    TargetRegistry::RegisterMCInstPrinter(
        getTheM88kTarget(), createM88kMCInstPrinter);
}
\end{cpp}
\end{enumerate}

Now we have implemented all required support classes, and we can finally add the assembler parser.

\mySamllsection{Creating the M88k assembler parser class}

There is only an M88kAsmParser.cpp implementation file in the AsmParser directory. The M88kOperand class represents a parsed operand and is used by the generated source code and our assembler parser implementation in class M88kAssembler. Both classes are in an anonymous namespace, only the factory method is globally visible. Letâ€™s take a look at the M88kOperand class first:

\begin{enumerate}
\item
An operand can be a token, a register, or an immediate. We define the OperandKind enumeration to distinguish between these cases. The current kind is stored in the Kind member. We also store the start and the end location of the operand, which is needed to print the error message:

\begin{cpp}
class M88kOperand : public MCParsedAsmOperand {
    enum OperandKind { OpKind_Token, OpKind_Reg,
                        OpKind_Imm };
    OperandKind Kind;
    SMLoc StartLoc, EndLoc;
\end{cpp}

\item
To store the value, we define a union. The token is stored as a StringRef and the register is identified by its number. The immediate is represented by the MCExpr class:

\begin{cpp}
    union {
        StringRef Token;
        unsigned RegNo;
        const MCExpr *Imm;
    };
\end{cpp}

\item
The constructor initializes all fields but the union. Furthermore, we define methods to return the value of the start and the end locations:

\begin{cpp}
public:
    M88kOperand(OperandKind Kind, SMLoc StartLoc,
                SMLoc EndLoc)
        : Kind(Kind), StartLoc(StartLoc), EndLoc(EndLoc) {}
    SMLoc getStartLoc() const override { return StartLoc; }
    SMLoc getEndLoc() const override { return EndLoc; }
\end{cpp}

\item
For each operand type, we must define four methods. For a register, the methods are isReg() to check whether the operand is a register, getReg() to return the value, createReg() to create a register operand, and addRegOperands() to add an operant to an instruction. The latter function is called by the generated source code when an instruction is constructed. The methods for the token and the immediate are similar:

\begin{cpp}
bool isReg() const override {
    return Kind == OpKind_Reg;
}

unsigned getReg() const override { return RegNo; }

static std::unique_ptr<M88kOperand>
createReg(unsigned Num, SMLoc StartLoc,
          SMLoc EndLoc) {
    auto Op = std::make_unique<M88kOperand>(
        OpKind_Reg, StartLoc, EndLoc);
    Op->RegNo = Num;
    return Op;
}

void addRegOperands(MCInst &Inst, unsigned N) const {
    assert(N == 1 && "Invalid number of operands");
    Inst.addOperand(MCOperand::createReg(getReg()));
}
\end{cpp}

\item
And last, the superclass defines an abstract print() virtual method that we need to implement. This is only used for debugging purposes:

\begin{cpp}
void print(raw_ostream &OS) const override {
    switch (Kind) {
        case OpKind_Imm:
            OS << "Imm: " << getImm() << "\n"; break;
        case OpKind_Token:
            OS << "Token: " << getToken() << "\n"; break;
        case OpKind_Reg:
            OS << "Reg: "
               << M88kInstPrinter::getRegisterName(getReg())
               << "\n"; break;
        }
    }
};
\end{cpp}

\end{enumerate}

Next, we declare the M88kAsmParser class. The anonymous name space will end after the declaration:

\begin{enumerate}
\item
At the beginning of the class we include the generated fragment:

\begin{cpp}
class M88kAsmParser : public MCTargetAsmParser {
#define GET_ASSEMBLER_HEADER
#include "M88kGenAsmMatcher.inc"
\end{cpp}

\item
Next, we define the required fields. We need a reference to the actual parser, which is of the MCAsmParser class, and a reference to the sub-target information:

\begin{cpp}
    MCAsmParser &Parser;
    const MCSubtargetInfo &SubtargetInfo;
\end{cpp}

\item
To implement the assembler, we override a couple of methods defined in the MCTargetAsmParser superclass. The MatchAndEmitInstruction() method tries to match an instruction and emits the instruction represented by an instance of the MCInst class. Parsing an instruction is done in the ParseInstruction() method, while the parseRegister() and tryParseRegister() methods are responsible for parsing the register. The other methods are required internally:

\begin{cpp}
    bool
    ParseInstruction(ParseInstructionInfo &Info,
                    StringRef Name, SMLoc NameLoc,
                    OperandVector &Operands) override;
    bool parseRegister(MCRegister &RegNo, SMLoc &StartLoc,
                        SMLoc &EndLoc) override;
    OperandMatchResultTy
    tryParseRegister(MCRegister &RegNo, SMLoc &StartLoc,
                    SMLoc &EndLoc) override;
    bool parseRegister(MCRegister &RegNo, SMLoc &StartLoc,
                        SMLoc &EndLoc,
                        bool RestoreOnFailure);
    bool parseOperand(OperandVector &Operands,
                        StringRef Mnemonic);
    bool MatchAndEmitInstruction(
        SMLoc IdLoc, unsigned &Opcode,
        OperandVector &Operands, MCStreamer &Out,
        uint64_t &ErrorInfo,
        bool MatchingInlineAsm) override;
\end{cpp}

\item
The constructor is defined inline. It mostly initializes all fields. This finishes the class declaration, after which the anonymous namespace ends:

\begin{cpp}
public:
    M88kAsmParser(const MCSubtargetInfo &STI,
                    MCAsmParser &Parser,
                    const MCInstrInfo &MII,
                    const MCTargetOptions &Options)
        : MCTargetAsmParser(Options, STI, MII),
            Parser(Parser), SubtargetInfo(STI) {
        setAvailableFeatures(ComputeAvailableFeatures(
            SubtargetInfo.getFeatureBits()));
    }
};
\end{cpp}

\item
Now we include the generated parts of the assembler:

\begin{cpp}
#define GET_REGISTER_MATCHER
#define GET_MATCHER_IMPLEMENTATION
#include "M88kGenAsmMatcher.inc"
\end{cpp}

\item
The ParseInstruction() method is called whenever an instruction is expected. It must be able to parse all syntactical forms of an instruction. Currently, we only have instructions that take three operands, which are separated by a comma, so the parsing is simple. Be aware that the return value is true in case of an error!

\begin{cpp}
bool M88kAsmParser::ParseInstruction(
        ParseInstructionInfo &Info, StringRef Name,
        SMLoc NameLoc, OperandVector &Operands) {
    Operands.push_back(
        M88kOperand::createToken(Name, NameLoc));
    if (getLexer().isNot(AsmToken::EndOfStatement)) {
        if (parseOperand(Operands, Name)) {
            return Error(getLexer().getLoc(),
                         "expected operand");
        }
        while (getLexer().is(AsmToken::Comma)) {
            Parser.Lex();
            if (parseOperand(Operands, Name)) {
                return Error(getLexer().getLoc(),
                "expected operand");
            }
        }
        if (getLexer().isNot(AsmToken::EndOfStatement))
            return Error(getLexer().getLoc(),
                "unexpected token in argument list");
    }
    Parser.Lex();
    return false;
}
\end{cpp}

\item
An operand can be a register or an immediate. We generalize a bit and parse an expression instead of just an integer. This helps later when adding address modes. When successful, the parsed operand is added to the Operands list:

\begin{cpp}
bool M88kAsmParser::parseOperand(
        OperandVector &Operands, StringRef Mnemonic) {
    if (Parser.getTok().is(AsmToken::Percent)) {
        MCRegister RegNo;
        SMLoc StartLoc, EndLoc;
        if (parseRegister(RegNo, StartLoc, EndLoc,
                        /*RestoreOnFailure=*/false))
            return true;
        Operands.push_back(M88kOperand::createReg(
            RegNo, StartLoc, EndLoc));
        return false;
    }

    if (Parser.getTok().is(AsmToken::Integer)) {
        SMLoc StartLoc = Parser.getTok().getLoc();
        const MCExpr *Expr;
        if (Parser.parseExpression(Expr))
            return true;
        SMLoc EndLoc = Parser.getTok().getLoc();
        Operands.push_back(
            M88kOperand::createImm(Expr, StartLoc, EndLoc));
        return false;
    }
    return true;
}
\end{cpp}

\item
The parseRegister() method tries to parse a register. First, it checks for a percent sign \%. If this is followed by an identifier which matches a register name, then we successfully parsed a register, and return the register number in the RegNo parameter. However, if we cannot identify a register, then we may need to undo the lexing if the RestoreOnFailure parameter is true:

\begin{cpp}
bool M88kAsmParser::parseRegister(
        MCRegister &RegNo, SMLoc &StartLoc, SMLoc &EndLoc,
        bool RestoreOnFailure) {
    StartLoc = Parser.getTok().getLoc();

    if (Parser.getTok().isNot(AsmToken::Percent))
        return true;
    const AsmToken &PercentTok = Parser.getTok();
    Parser.Lex();

    if (Parser.getTok().isNot(AsmToken::Identifier) ||
        (RegNo = MatchRegisterName(
            Parser.getTok().getIdentifier())) == 0) {
        if (RestoreOnFailure)
            Parser.getLexer().UnLex(PercentTok);
        return Error(StartLoc, "invalid register");
    }
    Parser.Lex();
    EndLoc = Parser.getTok().getLoc();
    return false;
}
\end{cpp}

\item
The parseRegister() and tryparseRegister() overridden methods are just wrappers around the previously defined method. The latter method also translates the boolean return value into an enumeration member of the OperandMatchResultTy enumeration:

\begin{cpp}
bool M88kAsmParser::parseRegister(MCRegister &RegNo,
                                    SMLoc &StartLoc,
                                    SMLoc &EndLoc) {
    return parseRegister(RegNo, StartLoc, EndLoc,
                         /*RestoreOnFailure=*/false);
}

OperandMatchResultTy M88kAsmParser::tryParseRegister(
        MCRegister &RegNo, SMLoc &StartLoc, SMLoc &EndLoc) {
    bool Result =
        parseRegister(RegNo, StartLoc, EndLoc,

    /*RestoreOnFailure=*/true);
    bool PendingErrors = getParser().hasPendingError();
    getParser().clearPendingErrors();
    if (PendingErrors)
        return MatchOperand_ParseFail;
    if (Result)
        return MatchOperand_NoMatch;
    return MatchOperand_Success;
}
\end{cpp}

\item
Finally, the MatchAndEmitInstruction() method drives the parsing. Most of the method is dedicated to emitting error messages. To identify the instruction, the MatchInstructionImpl() generated method is called:

\begin{cpp}
bool M88kAsmParser::MatchAndEmitInstruction(
        SMLoc IdLoc, unsigned &Opcode,
        OperandVector &Operands, MCStreamer &Out,
        uint64_t &ErrorInfo, bool MatchingInlineAsm) {
    MCInst Inst;
    SMLoc ErrorLoc;

    switch (MatchInstructionImpl(
            Operands, Inst, ErrorInfo, MatchingInlineAsm)) {
    case Match_Success:
        Out.emitInstruction(Inst, SubtargetInfo);
        Opcode = Inst.getOpcode();
        return false;
    case Match_MissingFeature:
        return Error(IdLoc, "Instruction use requires "
                     "option to be enabled");
    case Match_MnemonicFail:
        return Error(IdLoc,
                     "Unrecognized instruction mnemonic");
    case Match_InvalidOperand: {
        ErrorLoc = IdLoc;
        if (ErrorInfo != ~0U) {
            if (ErrorInfo >= Operands.size())
                return Error(
                    IdLoc, "Too few operands for instruction");
            ErrorLoc = ((M88kOperand &)*Operands[ErrorInfo])
                    .getStartLoc();
            if (ErrorLoc == SMLoc())
                ErrorLoc = IdLoc;
        }
        return Error(ErrorLoc,
                     "Invalid operand for instruction");
    }
    default:
        break;
    }
    llvm_unreachable("Unknown match type detected!");
}
\end{cpp}

\item
And like some other classes, the assembler parser has its own factory method:

\begin{cpp}
extern "C" LLVM_EXTERNAL_VISIBILITY void
LLVMInitializeM88kAsmParser() {
    RegisterMCAsmParser<M88kAsmParser> X(
        getTheM88kTarget());
}
\end{cpp}
\end{enumerate}

This finishes the implementation of the assembler parser. After building LLVM, we can use the llvm-mc machine code playground tool to assemble an instruction:

\begin{shell}
$ echo 'and %r1,%r2,%r3' | \
    bin/llvm-mc --triple m88k-openbsd --show-encoding
        .text
        and %r1, %r2, %r3 | encoding: [0xf4,0x22,0x40,0x03]
\end{shell}

Note the use of the vertical bar | as the comments sign. This is the value we configured in the M88kMCAsmInfo class.

\begin{myTip}{Debugging the assembler matcher}
To debug the assembler matcher, you specify the -{}-debug-only=asm-matcher commandline option. This helps with understanding why a parsed instruction fails to match the instructions defined in the target description.
\end{myTip}

In the next section, we will add a disassembler feature to the llvm-mc tool.































