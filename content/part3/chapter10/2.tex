
LLVM comes with a couple of sanitizers. These are passes that instrument the intermediate representation (IR) to check for certain misbehavior of an application. Usually, they require library support, which is part of the compiler-rt project. The sanitizers can be enabled in clang, which makes them very comfortable to use. To build the compiler-rt project, we can simply add the -DLLVM\_ENABLE\_RUNTIMES=compiler-rt CMake variable to the initial CMake configuration step when building LLVM.

In the following sections, we will look at the address, memory, and thread sanitizers. First, we’ll look at the address sanitizer

\mySubsubsection{10.2.1.}{Detecting memory access problems with the address sanitizer}

You can use the address sanitizer to detect different types of memory access bugs within an application. This includes common errors such as using dynamically allocated memory after freeing it or writing to dynamically allocated memory outside the boundaries of the allocated memory.

When enabled, the address sanitizer replaces calls to the malloc() and free() functions with its own version and instruments all memory accesses with a checking guard. Of course, this adds a lot of overhead to the application, and you will only use the address sanitizer during the testing phase of the application. If you are interested in the implementation details, then you can find the source of the pass in the llvm/lib/Transforms/Instrumentation/AddressSanitzer. cpp file and a description of the implemented algorithm at \url{https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm}.

Let’s run a short example to show the capabilities of the address sanitizer!

The following example application, outofbounds.c, allocates 12 bytes of memory, but initializes 14 bytes:

\begin{cpp}
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[]) {
    char *p = malloc(12);
    memset(p, 0, 14);
    return (int)*p;
}
\end{cpp}

You can compile and run this application without noticing a problem as this behavior is typical for this kind of error. Even in larger applications, such kinds of bugs can go unnoticed for a long time. However, if you enable the address sanitizer with the -fsanitize=address option, then the application stops after detecting the error.

It is also useful to enable debug symbols with the –g options because it helps identify the location of the error in the source. The following code is an example of how to compile the source file with the address sanitizer and debug symbols enabled:

\begin{shell}
$ clang -fsanitize=address -g outofbounds.c -o outofbounds
\end{shell}

Now, you get a lengthy error report when running the application:

\begin{shell}
$ ./outofbounds
==============================================================
==1067==ERROR: AddressSanitizer: heap-buffer-overflow on address
0x60200000001c at pc 0x00000023a6ef bp 0x7fffffffeb10 sp
0x7fffffffe2d8
WRITE of size 14 at 0x60200000001c thread T0
    #0 0x23a6ee in __asan_memset /usr/src/contrib/llvm-project/
compiler-rt/lib/asan/asan_interceptors_memintrinsics.cpp:26:3
    #1 0x2b2a03 in main /home/kai/sanitizers/outofbounds.c:6:3
    #2 0x23331f in _start /usr/src/lib/csu/amd64/crt1.c:76:7
\end{shell}

The report also contains detailed information about the memory content. The important information is the type of the error – heap buffer overflow, in this case – and the offending source line. To find the source line, you must look at the stack trace at location \#1, which is the last location before the address sanitizer intercepts the execution of the application. It shows line 6 in the outofbounds.c file, which is the line containing the call to memset(). This is the exact place where the buffer overflow happens.

If you replace the line containing memset(p, 0, 14); in the outofbounds.c file with the following code, then you can introduce access to memory once you’ve freed the memory. You’ll need to store the source in the useafterfree.c file:

\begin{cpp}
memset(p, 0, 12);
free(p);
\end{cpp}

Again, if you compile and run it, the sanitizer detects the use of the pointer after the memory is freed:

\begin{shell}
$ clang -fsanitize=address -g useafterfree.c -o useafterfree
$ ./useafterfree
==============================================================
==1118==ERROR: AddressSanitizer: heap-use-after-free on address
0x602000000010 at pc 0x0000002b2a5c bp 0x7fffffffeb00 sp
0x7fffffffeaf8
READ of size 1 at 0x602000000010 thread T0
    #0 0x2b2a5b in main /home/kai/sanitizers/useafterfree.c:8:15
    #1 0x23331f in _start /usr/src/lib/csu/amd64/crt1.c:76:7
\end{shell}

This time, the report points to line 8, which contains dereferencing of the p pointer.

On x86\_64 Linux and macOS, you can also enable a leak detector. If you set the ASAN\_OPTIONS environment variable to detect\_leaks=1 before running the application, then you also get a report about memory leaks.

On the command line, you can do this as follows:

\begin{shell}
$ ASAN_OPTIONS=detect_leaks=1 ./useafterfree
\end{shell}

The address sanitizer is very useful because it catches a category of bugs that are otherwise difficult to detect. The memory sanitizer does a similar task. We’ll examine its use cases in the next section.

\mySubsubsection{10.2.2.}{Finding uninitialized memory accesses with the memory sanitizer}

Using uninitialized memory is another category of bugs that are hard to find. In C and C++, the general memory allocation routines do not initialize the memory buffer with a default value. The same is true for automatic variables on the stack.

There are lots of opportunities for errors, and the memory sanitizer helps find these bugs. If you are interested in the implementation details, you can find the source for the memory sanitizer pass in the llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp file. The comment at the top of the file explains the ideas behind the implementation.

Let’s run a small example and save the following source as the memory.c file. Note that the x variable is not initialized and is used as a return value:

\begin{cpp}
int main(int argc, char *argv[]) {
    int x;
    return x;
}
\end{cpp}

Without the sanitizer, the application will run just fine. However, you will get an error report if you use the -fsanitize=memory option:

\begin{shell}
$ clang -fsanitize=memory -g memory.c -o memory
$ ./memory
==1206==WARNING: MemorySanitizer: use-of-uninitialized-value
    #0 0x10a8f49 in main /home/kai/sanitizers/memory.c:3:3
    #1 0x1053481 in _start /usr/src/lib/csu/amd64/crt1.c:76:7
SUMMARY: MemorySanitizer: use-of-uninitialized-value /home/kai/
sanitizers/memory.c:3:3 in main
Exiting
\end{shell}

Like the address sanitizer, the memory sanitizer stops the application at the first error that’s found. As shown here the memory sanitizer provides a use of initialized value warning.

Finally, in the next section, we’ll look at how we can use the thread sanitizer to detect data races in multi-threaded applications.

\mySubsubsection{10.2.3.}{Pointing out data races with the thread sanitizer}

To leverage the power of modern CPUs, applications now use multiple threads. This is a powerful technique, but it also introduces new sources of errors. A very common problem in multi-threaded applications is that the access to global data is not protected, for example, with a mutex or semaphore.

This is called a data race. The thread sanitizer can detect data races in Pthreads-based applications and in applications using the LLVM libc++ implementation. You can find the implementation in the llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp file.
To demonstrate the functionality of the thread sanitizer, we will create a very simple producerconsumer-style application. The producer thread increments a global variable, while the consumer thread decrements the same variable. Access to the global variable is not protected, so this is a data race.

You’ll need to save the following source in the thread.c file:

\begin{cpp}
#include <pthread.h>

int data = 0;

void *producer(void *x) {
    for (int i = 0; i < 10000; ++i) ++data;
    return x;
}

void *consumer(void *x) {
    for (int i = 0; i < 10000; ++i) --data;
    return x;
}

int main() {
    pthread_t t1, t2;
    pthread_create(&t1, NULL, producer, NULL);
    pthread_create(&t2, NULL, consumer, NULL);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    return data;
}
\end{cpp}

In the preceding code, the data variable is shared between two threads. Here, it is of the int type to make the example simple since often, a data structure such as the std::vector class or similar would be used. Furthermore, these two threads run the producer() and consumer() functions.

The producer() function only increments the data variable, while the consumer() function decrements it. No access protection is implemented, so this constitutes a data race. The main() function starts both threads with the pthread\_create() function, waits for the end of the threads with the pthread\_join() function, and returns the current value of the data variable.

If you compile and run this application, then you will note no error – that is, the return value is always zero. An error – in this case, a return value not equal to zero – will appear if the number of loops that are performed is increased by a factor of 100. At this point, you will begin to notice other values appear.

We can use the thread sanitizer to identify the data race within our program. To compile with the thread sanitizer enabled, you’ll need to pass the -fsanitize=thread option to clang. Adding debug symbols with the –g options gives you line numbers in the report, which is also helpful. Note that you also need to link the pthread library:

\begin{shell}
$ clang -fsanitize=thread -g thread.c -o thread -lpthread
$ ./thread
==================
WARNING: ThreadSanitizer: data race (pid=1474)
    Write of size 4 at 0x000000cdf8f8 by thread T2:
        #0 consumer /home/kai/sanitizers/thread.c:11:35 (thread+0x2b0fb2)

    Previous write of size 4 at 0x000000cdf8f8 by thread T1:
        #0 producer /home/kai/sanitizers/thread.c:6:35 (thread+0x2b0f22)

    Location is global 'data' of size 4 at 0x000000cdf8f8
(thread+0x000000cdf8f8)

    Thread T2 (tid=100437, running) created by main thread at:
        #0 pthread_create /usr/src/contrib/llvm-project/compiler-rt/lib/
tsan/rtl/tsan_interceptors_posix.cpp:962:3 (thread+0x271703)
        #1 main /home/kai/sanitizers/thread.c:18:3 (thread+0x2b1040)

Thread T1 (tid=100436, finished) created by main thread at:
    #0 pthread_create /usr/src/contrib/llvm-project/compiler-rt/lib/
tsan/rtl/tsan_interceptors_posix.cpp:962:3 (thread+0x271703)
    #1 main /home/kai/sanitizers/thread.c:17:3 (thread+0x2b1021)

SUMMARY: ThreadSanitizer: data race /home/kai/sanitizers/
thread.c:11:35 in consumer
==================
ThreadSanitizer: reported 1 warnings
\end{shell}

The report points us to lines 6 and 11 of the source file, where the global variable is accessed. It also shows that two threads named T1 and T2 accessed the variable and the file and line number of the respective calls to the pthread\_create() function.

With that, we’ve learned how to use three different types of sanitizers to identify common problems in applications. The address sanitizer helps us identify common memory access errors, such as out-of-bounds accesses or using memory after it’s been freed. Using the memory sanitizer, we can find access to uninitialized memory, and the thread sanitizer helps us identify data races.

In the next section, we’ll try to trigger the sanitizers by running our application on random data. This process is known as fuzz testing.



