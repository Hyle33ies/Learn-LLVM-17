If your application seems to run slow, then you might want to know where the time is spent in the code. Here, instrumenting the code with XRay can assist with this task. Basically, at each function entry and exit, a special call is inserted into the runtime library. This allows you to count how often a function is called, and also how much time is spent in the function. You can find the implementation for the instrumentation pass in the llvm/lib/XRay/ directory. The runtime portion is part of compiler-rt.

In the following example source, real work is simulated by calling the usleep() function. The func1() function sleeps for 10 µs. The func2() function calls func1() or sleeps for 100 µs, depending on if the n parameter is odd or even. Inside the main() function, both functions are called inside a loop. This is already enough to get interesting information. You’ll need to save the following source code in the xraydemo.c file:

\begin{cpp}
#include <unistd.h>

void func1() { usleep(10); }

void func2(int n) {
    if (n % 2) func1();
    else usleep(100);
}

int main(int argc, char *argv[]) {
    for (int i = 0; i < 100; i++) { func1(); func2(i); }
    return 0;
}
\end{cpp}

To enable the XRay instrumentation during compilation, you will need to specify the -fxrayinstrument option. It is worth noting that functions with less than 200 instructions are not instrumented. This is because this is an arbitrary threshold defined by the developers, and in our case, the functions would not be instrumented. The threshold can be specified with the -fxrayinstruction-threshold= option.

Alternatively, we can add a function attribute to control if a function should be instrumented. For example, adding the following prototype would result in us always instrumenting the function:

\begin{cpp}
void func1() __attribute__((xray_always_instrument));
\end{cpp}

Likewise, by using the xray\_never\_instrument attribute, you can turn off instrumentation for a function.

We will now use the command-line option and compile the xraydemo.c file, as follows:

\begin{shell}
$ clang -fxray-instrument -fxray-instruction-threshold=1 -g xraydemo.c -o xraydemo
\end{shell}

In the resulting binary, instrumentation is turned off by default. If you run the binary, you will note no difference compared to a non-instrumented binary. The XRAY\_OPTIONS environment variable is used to control the recording of runtime data. To enable data collection, you can run the application as follows:

\begin{shell}
$ XRAY_OPTIONS="patch_premain=true xray_mode=xray-basic" ./xraydemo
\end{shell}

The xray\_mode=xray-basic option tells the runtime that we want to use basic mode. In this mode, all runtime data is collected, which can result in large log files. When the patch\_premain=true option is given, functions that are run before the main() function are also instrumented.

After running this command, a new file will be created in the directory, in which the collected data is stored. You will need to use the llvm-xray tool to extract any readable information from this file.

The llvm-xray tool supports various sub-commands. First of all, you can use the account sub-command to extract some basic statistics. For example, to get the top 10 most called functions, you can add the -top=10 option to limit the output, and the -sort=count option to specify the function call count as the sort criteria. You can also influence the sort order with the -sortorder= option.

The following commands can be run to get the statistics from our program:

\begin{shell}
$ llvm-xray account xray-log.xraydemo.xVsWiE --sort=count\
--sortorder=dsc --instr_map ./xraydemo
Functions with latencies: 3
funcid   count      sum function
     1     150 0.166002 demo.c:4:0: func1
     2     100 0.543103 demo.c:9:0: func2
     3       1 0.655643 demo.c:17:0: main
\end{shell}

As you can see, the func1() function is called most often; you can also see the accumulated time spent in this function. This example only has three functions, so the –top= option has no visible effect here, but for real applications, it is very useful.

From the collected data, it is possible to reconstruct all the stack frames that occurred during runtime. You use the stack sub-command to view the top 10 stacks. The output shown here has been reduced for brevity:

\begin{shell}
$ llvm-xray stack xray-log.xraydemo.xVsWiE –instr_map ./xraydemo
Unique Stacks: 3
Top 10 Stacks by leaf sum:

Sum: 1325516912
lvl   function   count            sum
#0    main           1     1777862705
#1    func2         50     1325516912

Top 10 Stacks by leaf count:

Count: 100
lvl   function   count             sum
#0    main           1      1777862705
#1    func1        100       303596276
\end{shell}

A stack frame is the sequence of how a function is called. The func2() function is called by the main() function, and this is the stack frame with the largest accumulated time. The depth depends on how many functions are called, and the stack frames are usually large.

This sub-command can also be used to create a flame graph from the stack frames. With a flame graph, you can easily identify which functions have a large, accumulated runtime. The output is the stack frames with count and runtime information. Using the flamegraph.pl script, you can convert the data into a scalable vector graphics (SVG) file that you can view in your browser.

With the following command, you instruct llvm-xray to output all stack frames with the – all-stacks option. Using the –stack-format=flame option, the output is in the format expected by the flamegraph.pl script. Moreover, with the –aggregation-type option, you can choose if stack frames are aggregated by total time or by the number of invocations. The output of llvm-xray is piped into the flamegraph.pl script, and the resulting output is saved in the flame.svg file:

\begin{shell}
$ llvm-xray stack xray-log.xraydemo.xVsWiE --all-stacks\
    --stack-format=flame --aggregation-type=time\
    --instr_map ./xraydemo | flamegraph.pl >flame.svg
\end{shell}

After running the command and generating the new flame graph, you can open the generated flame. svg file in your browser. The graphic looks as follows:

\myGraphic{1.0}{content/part3/chapter10/images/1.png}{Figure 10.1 – Flame graph produced by llvm-xray}

Flame graphs can be confusing at first glance because the X-axis does not have the usual meaning of elapsed time. Instead, the functions are simply sorted alphabetically by name. Furthermore, the Y-axis of the flame graph shows the stack depth, where the bottom begins counting from zero. The colors are chosen to have a good contrast and have no other meaning. From the preceding graph, you can easily determine the call hierarchy and the time spent in a function.

Information about a stack frame is displayed only after you move the mouse cursor over the rectangle representing the frame. By clicking on the frame, you can zoom into this stack frame. Flame graphs are of great help if you want to identify functions worth optimizing. To find out more about flame graphs, please visit the website of Brendan Gregg, the inventor of flame graphs: \url{http://www.brendangregg.com/flamegraphs.html}.

Additionally, you can use the convert subcommand to convert the data into .yaml format or the format used by the Chrome Trace Viewer Visualization. The latter is another nice way to create a graphic from the data. To save the data in the xray.evt file, you can run the following command:

\begin{shell}
$ llvm-xray convert --output-format=trace_event\
    --output=xray.evt --symbolize --sort\
    --instr_map=./xraydemo xray-log.xraydemo.xVsWiE
\end{shell}

If you do not specify the –symbolize option, then no function names are shown in the resulting graph.

Once you’ve done that, open Chrome and type chrome:///tracing. Next, click on the Load button to load the xray.evt file. You will see the following visualization of the data:

\myGraphic{1.0}{content/part3/chapter10/images/2.png}{Figure 10.2 – Chrome Trace Viewer Visualization generated by llvm-xray}

In this view, the stack frames are sorted by the time the function call occurs. For further interpretation of the visualization, please read the tutorial at \url{https://www.chromium.org/developers/how-tos/trace-event-profiling-tool}.

\begin{myTip}{Tip}
The llvm-xray tool has more functionality that is applicable for performance profiling. You can read about it on the LLVM website at \url{https://llvm.org/docs/XRay.html} and \url{https://llvm.org/docs/XRayExample.html}.
\end{myTip}

In this section, we learned how to instrument an application with XRay, how to collect runtime information, and how to visualize that data. We can use this knowledge to find performance bottlenecks in applications.

Another approach to identifying errors in an application is to analyze the source code, which is done with the clang static analyzer.























